{"$message_type":"diagnostic","message":"the name `PgPool` is defined multiple times","code":{"code":"E0252","explanation":"Two items of the same name cannot be imported without rebinding one of the\nitems under a new local name.\n\nErroneous code example:\n\n```compile_fail,E0252\nuse foo::baz;\nuse bar::baz; // error, do `use bar::baz as quux` instead\n\nfn main() {}\n\nmod foo {\n    pub struct baz;\n}\n\nmod bar {\n    pub mod baz {}\n}\n```\n\nYou can use aliases in order to fix this error. Example:\n\n```\nuse foo::baz as foo_baz;\nuse bar::baz; // ok!\n\nfn main() {}\n\nmod foo {\n    pub struct baz;\n}\n\nmod bar {\n    pub mod baz {}\n}\n```\n\nOr you can reference the item with its parent:\n\n```\nuse bar::baz;\n\nfn main() {\n    let x = foo::baz; // ok!\n}\n\nmod foo {\n    pub struct baz;\n}\n\nmod bar {\n    pub mod baz {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":291,"byte_end":297,"line_start":13,"line_end":13,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"use sqlx::{PgPool, Pool, Postgres, Row};","highlight_start":12,"highlight_end":18}],"label":"`PgPool` reimported here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/db.rs","byte_start":23,"byte_end":35,"line_start":2,"line_end":2,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"use sqlx::PgPool;","highlight_start":5,"highlight_end":17}],"label":"previous import of the type `PgPool` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`PgPool` must be defined only once in the type namespace of this module","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove unnecessary import","code":null,"level":"help","spans":[{"file_name":"src/db.rs","byte_start":291,"byte_end":299,"line_start":13,"line_end":13,"column_start":12,"column_end":20,"is_primary":true,"text":[{"text":"use sqlx::{PgPool, Pool, Postgres, Row};","highlight_start":12,"highlight_end":20}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0252]\u001b[0m\u001b[0m\u001b[1m: the name `PgPool` is defined multiple times\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:13:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse sqlx::PgPool;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mprevious import of the type `PgPool` here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse sqlx::{PgPool, Pool, Postgres, Row};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`PgPool` reimported here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove unnecessary import\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `PgPool` must be defined only once in the type namespace of this module\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"optional sqlx feature `uuid` required for type UUID of column #1 (\"id\")","code":null,"level":"error","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/db.rs","byte_start":793,"byte_end":1048,"line_start":32,"line_end":39,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = sqlx::query!(","highlight_start":22,"highlight_end":35},{"text":"            \"INSERT INTO users (username, email, password_hash, created_at, updated_at) VALUES ($1, $2, $3, $4, $5) RETURNING *\",","highlight_start":1,"highlight_end":130},{"text":"            username,","highlight_start":1,"highlight_end":22},{"text":"            password_hash,","highlight_start":1,"highlight_end":27},{"text":"            email,","highlight_start":1,"highlight_end":19},{"text":"            now,","highlight_start":1,"highlight_end":17},{"text":"            now,","highlight_start":1,"highlight_end":17},{"text":"        )","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: optional sqlx feature `uuid` required for type UUID of column #1 (\"id\")\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:32:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = sqlx::query!(\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m ______________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            \"INSERT INTO users (username, email, password_hash, created_at, updated_at) VALUES ($1, $2, $3, $4, $5) RETURNING *\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            username,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            password_hash,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            now,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        )\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_________^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"optional sqlx feature `uuid` required for type UUID of column #1 (\"id\")","code":null,"level":"error","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/db.rs","byte_start":793,"byte_end":1048,"line_start":32,"line_end":39,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = sqlx::query!(","highlight_start":22,"highlight_end":35},{"text":"            \"INSERT INTO users (username, email, password_hash, created_at, updated_at) VALUES ($1, $2, $3, $4, $5) RETURNING *\",","highlight_start":1,"highlight_end":130},{"text":"            username,","highlight_start":1,"highlight_end":22},{"text":"            password_hash,","highlight_start":1,"highlight_end":27},{"text":"            email,","highlight_start":1,"highlight_end":19},{"text":"            now,","highlight_start":1,"highlight_end":17},{"text":"            now,","highlight_start":1,"highlight_end":17},{"text":"        )","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: optional sqlx feature `uuid` required for type UUID of column #1 (\"id\")\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:32:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = sqlx::query!(\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m ______________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            \"INSERT INTO users (username, email, password_hash, created_at, updated_at) VALUES ($1, $2, $3, $4, $5) RETURNING *\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            username,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            password_hash,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            now,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        )\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_________^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"optional sqlx feature `uuid` required for type UUID of column #1 (\"id\")","code":null,"level":"error","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/users.rs","byte_start":3958,"byte_end":4077,"line_start":143,"line_end":146,"column_start":18,"column_end":10,"is_primary":false,"text":[{"text":"    let result = sqlx::query!(","highlight_start":18,"highlight_end":31},{"text":"        \"SELECT id, email, username, password_hash FROM users WHERE email = $1\",","highlight_start":1,"highlight_end":81},{"text":"        email,","highlight_start":1,"highlight_end":15},{"text":"        )","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: optional sqlx feature `uuid` required for type UUID of column #1 (\"id\")\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:143:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m143\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let result = sqlx::query!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m __________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"SELECT id, email, username, password_hash FROM users WHERE email = $1\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m145\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        email,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        )\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"optional sqlx feature `uuid` required for type UUID of column #1 (\"id\")","code":null,"level":"error","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/users.rs","byte_start":3958,"byte_end":4077,"line_start":143,"line_end":146,"column_start":18,"column_end":10,"is_primary":false,"text":[{"text":"    let result = sqlx::query!(","highlight_start":18,"highlight_end":31},{"text":"        \"SELECT id, email, username, password_hash FROM users WHERE email = $1\",","highlight_start":1,"highlight_end":81},{"text":"        email,","highlight_start":1,"highlight_end":15},{"text":"        )","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: optional sqlx feature `uuid` required for type UUID of column #1 (\"id\")\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:143:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m143\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let result = sqlx::query!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m __________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"SELECT id, email, username, password_hash FROM users WHERE email = $1\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m145\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        email,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        )\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"optional sqlx feature `uuid` required for type UUID of param #1","code":null,"level":"error","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/strategies.rs","byte_start":426,"byte_end":610,"line_start":21,"line_end":26,"column_start":18,"column_end":6,"is_primary":false,"text":[{"text":"    let result = sqlx::query!(","highlight_start":18,"highlight_end":31},{"text":"        \"INSERT INTO strategies (user_id, title, content) VALUES ($1, $2, $3) RETURNING id\",","highlight_start":1,"highlight_end":93},{"text":"        payload.user_id,","highlight_start":1,"highlight_end":25},{"text":"        payload.title,","highlight_start":1,"highlight_end":23},{"text":"        payload.content","highlight_start":1,"highlight_end":24},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: optional sqlx feature `uuid` required for type UUID of param #1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/strategies.rs:21:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let result = sqlx::query!(\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m __________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"INSERT INTO strategies (user_id, title, content) VALUES ($1, $2, $3) RETURNING id\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        payload.user_id,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        payload.title,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        payload.content\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    )\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"optional sqlx feature `uuid` required for type UUID of column #1 (\"id\")","code":null,"level":"error","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/store/user_store.rs","byte_start":178,"byte_end":362,"line_start":6,"line_end":11,"column_start":18,"column_end":6,"is_primary":false,"text":[{"text":"    let result = sqlx::query!(","highlight_start":18,"highlight_end":31},{"text":"        \"INSERT INTO users (username, password_hash, email) VALUES ($1, $2, $3) RETURNING id\",","highlight_start":1,"highlight_end":95},{"text":"        user.username,","highlight_start":1,"highlight_end":23},{"text":"        user.password_hash,","highlight_start":1,"highlight_end":28},{"text":"        user.email","highlight_start":1,"highlight_end":19},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: optional sqlx feature `uuid` required for type UUID of column #1 (\"id\")\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/store/user_store.rs:6:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let result = sqlx::query!(\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m __________________^\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"INSERT INTO users (username, password_hash, email) VALUES ($1, $2, $3) RETURNING id\",\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        user.username,\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        user.password_hash,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        user.email\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    )\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"optional sqlx feature `uuid` required for type UUID of column #1 (\"id\")","code":null,"level":"error","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/store/user_store.rs","byte_start":178,"byte_end":362,"line_start":6,"line_end":11,"column_start":18,"column_end":6,"is_primary":false,"text":[{"text":"    let result = sqlx::query!(","highlight_start":18,"highlight_end":31},{"text":"        \"INSERT INTO users (username, password_hash, email) VALUES ($1, $2, $3) RETURNING id\",","highlight_start":1,"highlight_end":95},{"text":"        user.username,","highlight_start":1,"highlight_end":23},{"text":"        user.password_hash,","highlight_start":1,"highlight_end":28},{"text":"        user.email","highlight_start":1,"highlight_end":19},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: optional sqlx feature `uuid` required for type UUID of column #1 (\"id\")\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/store/user_store.rs:6:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let result = sqlx::query!(\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m __________________^\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"INSERT INTO users (username, password_hash, email) VALUES ($1, $2, $3) RETURNING id\",\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        user.username,\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        user.password_hash,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        user.email\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    )\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"optional sqlx feature `uuid` required for type UUID of param #1","code":null,"level":"error","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":true,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":16656,"byte_end":16727,"line_start":332,"line_end":332,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        $crate::sqlx_macros::expand_query!(source = $query, args = [$($args)*])","highlight_start":9,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/store/user_store.rs","byte_start":605,"byte_end":695,"line_start":25,"line_end":28,"column_start":18,"column_end":6,"is_primary":false,"text":[{"text":"    let result = sqlx::query!(","highlight_start":18,"highlight_end":31},{"text":"        \"SELECT username, email FROM users WHERE id = $1\",","highlight_start":1,"highlight_end":59},{"text":"        id,","highlight_start":1,"highlight_end":12},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"sqlx::query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-0.7.4/src/macros/mod.rs","byte_start":15748,"byte_end":15766,"line_start":318,"line_end":318,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! query (","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::sqlx_macros::expand_query!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":89,"byte_end":143,"line_start":8,"line_end":8,"column_start":1,"column_end":55,"is_primary":false,"text":[{"text":"pub fn expand_query(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: optional sqlx feature `uuid` required for type UUID of param #1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/store/user_store.rs:25:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    let result = sqlx::query!(\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m __________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        \"SELECT username, email FROM users WHERE id = $1\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        id,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    )\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::sqlx_macros::expand_query` which comes from the expansion of the macro `sqlx::query` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `crate::middlewares`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/routes.rs","byte_start":123,"byte_end":134,"line_start":7,"line_end":7,"column_start":32,"column_end":43,"is_primary":true,"text":[{"text":"use crate::{app::health_check, middlewares, AppState};","highlight_start":32,"highlight_end":43}],"label":"no `middlewares` in the root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"src/routes.rs","byte_start":123,"byte_end":134,"line_start":7,"line_end":7,"column_start":32,"column_end":43,"is_primary":true,"text":[{"text":"use crate::{app::health_check, middlewares, AppState};","highlight_start":32,"highlight_end":43}],"label":null,"suggested_replacement":"middleware","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `crate::middlewares`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/routes.rs:7:32\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse crate::{app::health_check, middlewares, AppState};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `middlewares` in the root\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a similar name exists in the module: `middleware`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `AppState` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/users.rs","byte_start":443,"byte_end":451,"line_start":21,"line_end":21,"column_start":6,"column_end":14,"is_primary":true,"text":[{"text":"impl AppState {","highlight_start":6,"highlight_end":14}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/handlers/users.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::Arc;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::AppState;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `AppState` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:21:6\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl AppState {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this struct\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ use crate::AppState;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `AppState` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/users.rs","byte_start":2505,"byte_end":2513,"line_start":99,"line_end":99,"column_start":41,"column_end":49,"is_primary":true,"text":[{"text":"        Extension(state): Extension<Arc<AppState>>,","highlight_start":41,"highlight_end":49}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/handlers/users.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::Arc;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::AppState;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `AppState` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:99:41\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m99\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Extension(state): Extension<Arc<AppState>>,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this struct\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ use crate::AppState;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find tuple struct or tuple variant `TypedHeader` in this scope","code":{"code":"E0531","explanation":"An unknown tuple struct/variant has been used.\n\nErroneous code example:\n\n```compile_fail,E0531\nlet Type(x) = Type(12); // error!\nmatch Bar(12) {\n    Bar(x) => {} // error!\n    _ => {}\n}\n```\n\nIn most cases, it's either a forgotten import or a typo. However, let's look at\nhow you can have such a type:\n\n```edition2018\nstruct Type(u32); // this is a tuple struct\n\nenum Foo {\n    Bar(u32), // this is a tuple variant\n}\n\nuse Foo::*; // To use Foo's variant directly, we need to import them in\n            // the scope.\n```\n\nEither way, it should work fine with our previous code:\n\n```edition2018\nstruct Type(u32);\n\nenum Foo {\n    Bar(u32),\n}\nuse Foo::*;\n\nlet Type(x) = Type(12); // ok!\nmatch Type(12) {\n    Type(x) => {} // ok!\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/users.rs","byte_start":5069,"byte_end":5080,"line_start":192,"line_end":192,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"    TypedHeader(cookies): TypedHeader<HeaderCookie>,","highlight_start":5,"highlight_end":16}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0531]\u001b[0m\u001b[0m\u001b[1m: cannot find tuple struct or tuple variant `TypedHeader` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:192:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m192\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    TypedHeader(cookies): TypedHeader<HeaderCookie>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `AppState` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/users.rs","byte_start":5053,"byte_end":5061,"line_start":191,"line_end":191,"column_start":37,"column_end":45,"is_primary":true,"text":[{"text":"    Extension(state): Extension<Arc<AppState>>,","highlight_start":37,"highlight_end":45}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/handlers/users.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::Arc;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::AppState;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `AppState` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:191:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m191\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Extension(state): Extension<Arc<AppState>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this struct\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ use crate::AppState;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `TypedHeader` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/users.rs","byte_start":5091,"byte_end":5102,"line_start":192,"line_end":192,"column_start":27,"column_end":38,"is_primary":true,"text":[{"text":"    TypedHeader(cookies): TypedHeader<HeaderCookie>,","highlight_start":27,"highlight_end":38}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `TypedHeader` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:192:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m192\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    TypedHeader(cookies): TypedHeader<HeaderCookie>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `HeaderCookie` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/users.rs","byte_start":5103,"byte_end":5115,"line_start":192,"line_end":192,"column_start":39,"column_end":51,"is_primary":true,"text":[{"text":"    TypedHeader(cookies): TypedHeader<HeaderCookie>,","highlight_start":39,"highlight_end":51}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/handlers/users.rs","byte_start":5015,"byte_end":5015,"line_start":190,"line_end":190,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"async fn logout(","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":"<HeaderCookie>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `HeaderCookie` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:192:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m192\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    TypedHeader(cookies): TypedHeader<HeaderCookie>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you might be missing a type parameter\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m190\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0masync fn logout\u001b[0m\u001b[0m\u001b[38;5;10m<HeaderCookie>\u001b[0m\u001b[0m(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `AppError` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/middleware.rs","byte_start":419,"byte_end":427,"line_start":22,"line_end":22,"column_start":22,"column_end":30,"is_primary":true,"text":[{"text":"    type Rejection = AppError;","highlight_start":22,"highlight_end":30}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"src/middleware.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::Arc;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use crate::errors::AppError;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `AppError` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/middleware.rs:22:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    type Rejection = AppError;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this enum\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ use crate::errors::AppError;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `RequestParts` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/axum-core-0.4.5/src/extract/mod.rs","byte_start":1550,"byte_end":1586,"line_start":52,"line_end":52,"column_start":1,"column_end":37,"is_primary":false,"text":[{"text":"pub trait FromRequestParts<S>: Sized {","highlight_start":1,"highlight_end":37}],"label":"similarly named trait `FromRequestParts` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/middleware.rs","byte_start":474,"byte_end":486,"line_start":24,"line_end":24,"column_start":45,"column_end":57,"is_primary":true,"text":[{"text":"    async fn from_request_parts(parts: &mut RequestParts, ctx: &AppState) -> Result<Self, Self::Rejection> {","highlight_start":45,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a trait with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/middleware.rs","byte_start":474,"byte_end":486,"line_start":24,"line_end":24,"column_start":45,"column_end":57,"is_primary":true,"text":[{"text":"    async fn from_request_parts(parts: &mut RequestParts, ctx: &AppState) -> Result<Self, Self::Rejection> {","highlight_start":45,"highlight_end":57}],"label":null,"suggested_replacement":"FromRequestParts","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `RequestParts` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/middleware.rs:24:45\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    async fn from_request_parts(parts: &mut RequestParts, ctx: &AppState) -> Result<Self, Self::Rejection> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a trait with a similar name exists: `FromRequestParts`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/axum-core-0.4.5/src/extract/mod.rs:52:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait FromRequestParts<S>: Sized {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12msimilarly named trait `FromRequestParts` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `CookieJar`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/middleware.rs","byte_start":561,"byte_end":570,"line_start":25,"line_end":25,"column_start":23,"column_end":32,"is_primary":true,"text":[{"text":"        let cookies = CookieJar::from_request_parts(parts, ctx).await.expect(\"extracting cookies should be infallible\");","highlight_start":23,"highlight_end":32}],"label":"use of undeclared type `CookieJar`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/middleware.rs","byte_start":561,"byte_end":570,"line_start":25,"line_end":25,"column_start":23,"column_end":32,"is_primary":true,"text":[{"text":"        let cookies = CookieJar::from_request_parts(parts, ctx).await.expect(\"extracting cookies should be infallible\");","highlight_start":23,"highlight_end":32}],"label":null,"suggested_replacement":"Cookie","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/middleware.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::Arc;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use axum_extra::extract::CookieJar;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/middleware.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::sync::Arc;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use cookie::CookieJar;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `CookieJar`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/middleware.rs:25:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let cookies = CookieJar::from_request_parts(parts, ctx).await.expect(\"extracting cookies should be infallible\");\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `CookieJar`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: a struct with a similar name exists\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        let cookies = \u001b[0m\u001b[0m\u001b[38;5;9mCookieJar\u001b[0m\u001b[0m::from_request_parts(parts, ctx).await.expect(\"extracting cookies should be infallible\");\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        let cookies = \u001b[0m\u001b[0m\u001b[38;5;10mCookie\u001b[0m\u001b[0m::from_request_parts(parts, ctx).await.expect(\"extracting cookies should be infallible\");\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing one of these structs\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ use axum_extra::extract::CookieJar;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ use cookie::CookieJar;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `register` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1390,"byte_end":1398,"line_start":57,"line_end":57,"column_start":38,"column_end":46,"is_primary":true,"text":[{"text":"        .route(\"/api/register\", post(register))","highlight_start":38,"highlight_end":46}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this function","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use tracing::callsite::register;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find value `register` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:57:38\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .route(\"/api/register\", post(register))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this function\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ use tracing::callsite::register;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `login` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1435,"byte_end":1440,"line_start":58,"line_end":58,"column_start":35,"column_end":40,"is_primary":true,"text":[{"text":"        .route(\"/api/login\", post(login))","highlight_start":35,"highlight_end":40}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this function","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use crate::handlers::users::login;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find value `login` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:58:35\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .route(\"/api/login\", post(login))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this function\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ use crate::handlers::users::login;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `logout` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1478,"byte_end":1484,"line_start":59,"line_end":59,"column_start":36,"column_end":42,"is_primary":true,"text":[{"text":"        .route(\"/api/logout\", post(logout))","highlight_start":36,"highlight_end":42}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function `crate::handlers::users::logout` exists but is inaccessible","code":null,"level":"note","spans":[{"file_name":"src/handlers/users.rs","byte_start":5000,"byte_end":5662,"line_start":190,"line_end":212,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"async fn logout(","highlight_start":1,"highlight_end":17},{"text":"    Extension(state): Extension<Arc<AppState>>,","highlight_start":1,"highlight_end":48},{"text":"    TypedHeader(cookies): TypedHeader<HeaderCookie>,","highlight_start":1,"highlight_end":53},{"text":") -> impl IntoResponse {","highlight_start":1,"highlight_end":25},{"text":"    if let Some(session_id) = cookies.get(\"session_id\") {","highlight_start":1,"highlight_end":58},{"text":"        let mut con = state.redis_conn().await;","highlight_start":1,"highlight_end":48},{"text":"        let key = format!(\"session:{}\", session_id);","highlight_start":1,"highlight_end":53},{"text":"        let _: () = con.del(key).await.unwrap_or(());","highlight_start":1,"highlight_end":54},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Clear cookie","highlight_start":1,"highlight_end":20},{"text":"    let cookie = Cookie::build(\"session_id\", \"\")","highlight_start":1,"highlight_end":49},{"text":"        .http_only(true)","highlight_start":1,"highlight_end":25},{"text":"        .secure(true)","highlight_start":1,"highlight_end":22},{"text":"        .path(\"/\")","highlight_start":1,"highlight_end":19},{"text":"        .max_age(time::Duration::seconds(0))","highlight_start":1,"highlight_end":45},{"text":"        .finish();","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        [(axum::http::header::SET_COOKIE, cookie.to_string())],","highlight_start":1,"highlight_end":64},{"text":"        \"Logged out\",","highlight_start":1,"highlight_end":22},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"not accessible","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find value `logout` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:59:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .route(\"/api/logout\", post(logout))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function `crate::handlers::users::logout` exists but is inaccessible\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:190:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m190\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0masync fn logout(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m191\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Extension(state): Extension<Arc<AppState>>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m192\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    TypedHeader(cookies): TypedHeader<HeaderCookie>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m193\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m) -> impl IntoResponse {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mnot accessible\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `get_current_user` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1517,"byte_end":1533,"line_start":60,"line_end":60,"column_start":31,"column_end":47,"is_primary":true,"text":[{"text":"        .route(\"/api/me\", get(get_current_user))","highlight_start":31,"highlight_end":47}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find value `get_current_user` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:60:31\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .route(\"/api/me\", get(get_current_user))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `protected_route` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1573,"byte_end":1588,"line_start":61,"line_end":61,"column_start":38,"column_end":53,"is_primary":true,"text":[{"text":"        .route(\"/api/protected\", get(protected_route))","highlight_start":38,"highlight_end":53}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find value `protected_route` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:61:38\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .route(\"/api/protected\", get(protected_route))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `redis::Client`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/db.rs","byte_start":4,"byte_end":17,"line_start":1,"line_end":1,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"use redis::Client;","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/db.rs","byte_start":0,"byte_end":19,"line_start":1,"line_end":2,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use redis::Client;","highlight_start":1,"highlight_end":19},{"text":"use sqlx::PgPool;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `redis::Client`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse redis::Client;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `PgPool`, `Pool`, and `Postgres`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/db.rs","byte_start":291,"byte_end":297,"line_start":13,"line_end":13,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"use sqlx::{PgPool, Pool, Postgres, Row};","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/db.rs","byte_start":299,"byte_end":303,"line_start":13,"line_end":13,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"use sqlx::{PgPool, Pool, Postgres, Row};","highlight_start":20,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/db.rs","byte_start":305,"byte_end":313,"line_start":13,"line_end":13,"column_start":26,"column_end":34,"is_primary":true,"text":[{"text":"use sqlx::{PgPool, Pool, Postgres, Row};","highlight_start":26,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/db.rs","byte_start":291,"byte_end":315,"line_start":13,"line_end":13,"column_start":12,"column_end":36,"is_primary":true,"text":[{"text":"use sqlx::{PgPool, Pool, Postgres, Row};","highlight_start":12,"highlight_end":36}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/db.rs","byte_start":290,"byte_end":291,"line_start":13,"line_end":13,"column_start":11,"column_end":12,"is_primary":true,"text":[{"text":"use sqlx::{PgPool, Pool, Postgres, Row};","highlight_start":11,"highlight_end":12}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/db.rs","byte_start":318,"byte_end":319,"line_start":13,"line_end":13,"column_start":39,"column_end":40,"is_primary":true,"text":[{"text":"use sqlx::{PgPool, Pool, Postgres, Row};","highlight_start":39,"highlight_end":40}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused imports: `PgPool`, `Pool`, and `Postgres`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:13:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse sqlx::{PgPool, Pool, Postgres, Row};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `sqlx::PgPool`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/routes.rs","byte_start":77,"byte_end":89,"line_start":5,"line_end":5,"column_start":5,"column_end":17,"is_primary":true,"text":[{"text":"use sqlx::PgPool;","highlight_start":5,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/routes.rs","byte_start":73,"byte_end":91,"line_start":5,"line_end":6,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use sqlx::PgPool;","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `sqlx::PgPool`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/routes.rs:5:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse sqlx::PgPool;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `Path`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/users.rs","byte_start":143,"byte_end":147,"line_start":8,"line_end":8,"column_start":15,"column_end":19,"is_primary":true,"text":[{"text":"    extract::{Path, State}, http::StatusCode, response::IntoResponse, Extension, Json","highlight_start":15,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/handlers/users.rs","byte_start":143,"byte_end":149,"line_start":8,"line_end":8,"column_start":15,"column_end":21,"is_primary":true,"text":[{"text":"    extract::{Path, State}, http::StatusCode, response::IntoResponse, Extension, Json","highlight_start":15,"highlight_end":21}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/handlers/users.rs","byte_start":142,"byte_end":143,"line_start":8,"line_end":8,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"    extract::{Path, State}, http::StatusCode, response::IntoResponse, Extension, Json","highlight_start":14,"highlight_end":15}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/handlers/users.rs","byte_start":154,"byte_end":155,"line_start":8,"line_end":8,"column_start":26,"column_end":27,"is_primary":true,"text":[{"text":"    extract::{Path, State}, http::StatusCode, response::IntoResponse, Extension, Json","highlight_start":26,"highlight_end":27}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `Path`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:8:15\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    extract::{Path, State}, http::StatusCode, response::IntoResponse, Extension, Json\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::time::Duration`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/auth.rs","byte_start":4,"byte_end":23,"line_start":1,"line_end":1,"column_start":5,"column_end":24,"is_primary":true,"text":[{"text":"use std::time::Duration;","highlight_start":5,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/auth.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":2,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::time::Duration;","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::time::Duration`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::time::Duration;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"lifetime parameters or bounds on associated function `from_request_parts` do not match the trait declaration","code":{"code":"E0195","explanation":"The lifetime parameters of the method do not match the trait declaration.\n\nErroneous code example:\n\n```compile_fail,E0195\ntrait Trait {\n    fn bar<'a,'b:'a>(x: &'a str, y: &'b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn bar<'a,'b>(x: &'a str, y: &'b str) {\n    // error: lifetime parameters or bounds on method `bar`\n    // do not match the trait declaration\n    }\n}\n```\n\nThe lifetime constraint `'b` for `bar()` implementation does not match the\ntrait declaration. Ensure lifetime declarations match exactly in both trait\ndeclaration and implementation. Example:\n\n```\ntrait Trait {\n    fn t<'a,'b:'a>(x: &'a str, y: &'b str);\n}\n\nstruct Foo;\n\nimpl Trait for Foo {\n    fn t<'a,'b:'a>(x: &'a str, y: &'b str) { // ok!\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src/middleware.rs","byte_start":461,"byte_end":461,"line_start":24,"line_end":24,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"    async fn from_request_parts(parts: &mut RequestParts, ctx: &AppState) -> Result<Self, Self::Rejection> {","highlight_start":32,"highlight_end":32}],"label":"lifetimes do not match associated function in trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0195]\u001b[0m\u001b[0m\u001b[1m: lifetime parameters or bounds on associated function `from_request_parts` do not match the trait declaration\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/middleware.rs:24:32\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    async fn from_request_parts(parts: &mut RequestParts, ctx: &AppState) -> Result<Self, Self::Rejection> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mlifetimes do not match associated function in trait\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1202,"byte_end":1209,"line_start":46,"line_end":46,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"                    id: user.id,","highlight_start":25,"highlight_end":32}],"label":"expected `Uuid`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:46:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    id: user.id,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Uuid`, found `()`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Uuid: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1710,"byte_end":1714,"line_start":58,"line_end":58,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"        let user = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE email = $1\")","highlight_start":40,"highlight_end":44}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Uuid`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 48 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::User` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models.rs","byte_start":171,"byte_end":184,"line_start":9,"line_end":9,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models.rs","byte_start":171,"byte_end":184,"line_start":9,"line_end":9,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models.rs","byte_start":198,"byte_end":202,"line_start":10,"line_end":10,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct User {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Uuid: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:58:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let user = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE email = $1\")\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `sqlx::Decode<'_, _>` is not implemented for `Uuid`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\u001b[0m\n\u001b[0m              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\u001b[0m\n\u001b[0m              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\u001b[0m\n\u001b[0m              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\u001b[0m\n\u001b[0m              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\u001b[0m\n\u001b[0m              `&'r str` implements `sqlx::Decode<'r, Postgres>`\u001b[0m\n\u001b[0m              `()` implements `sqlx::Decode<'r, Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\u001b[0m\n\u001b[0m            and 48 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `models::User` to implement `for<'r> FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/models.rs:9:48\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct User {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m342\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m345\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Uuid: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1710,"byte_end":1714,"line_start":58,"line_end":58,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"        let user = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE email = $1\")","highlight_start":40,"highlight_end":44}],"label":"the trait `Type<_>` is not implemented for `Uuid`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::User` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models.rs","byte_start":171,"byte_end":184,"line_start":9,"line_end":9,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models.rs","byte_start":171,"byte_end":184,"line_start":9,"line_end":9,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models.rs","byte_start":198,"byte_end":202,"line_start":10,"line_end":10,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct User {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Uuid: Type<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:58:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let user = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE email = $1\")\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Type<_>` is not implemented for `Uuid`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Type<DB>`:\u001b[0m\n\u001b[0m              `&T` implements `Type<DB>`\u001b[0m\n\u001b[0m              `()` implements `Type<Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2, T3)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2, T3, T4)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m            and 50 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `models::User` to implement `for<'r> FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/models.rs:9:48\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct User {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m342\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m345\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_optional` exists for struct `QueryAs<'_, _, models::User, _>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1690,"byte_end":1794,"line_start":58,"line_end":60,"column_start":20,"column_end":14,"is_primary":false,"text":[{"text":"        let user = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE email = $1\")","highlight_start":20,"highlight_end":85},{"text":"            .bind(email)","highlight_start":1,"highlight_end":25},{"text":"            .fetch_optional(&self.pool)","highlight_start":1,"highlight_end":14}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/db.rs","byte_start":1794,"byte_end":1808,"line_start":60,"line_end":60,"column_start":14,"column_end":28,"is_primary":true,"text":[{"text":"            .fetch_optional(&self.pool)","highlight_start":14,"highlight_end":28}],"label":"method cannot be called on `QueryAs<'_, _, models::User, _>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models.rs","byte_start":187,"byte_end":202,"line_start":10,"line_end":10,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub struct User {","highlight_start":1,"highlight_end":16}],"label":"doesn't satisfy `models::User: FromRow<'r, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/uuid-1.18.1/src/lib.rs","byte_start":13742,"byte_end":13757,"line_start":459,"line_end":459,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub struct Uuid(Bytes);","highlight_start":1,"highlight_end":16}],"label":"doesn't satisfy `Uuid: Type<_>` or `Uuid: sqlx::Decode<'_, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Uuid: Type<_>`\n`Uuid: sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `fetch_optional` exists for struct `QueryAs<'_, _, models::User, _>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:60:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let user = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE email = $1\")\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ____________________-\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .bind(email)\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .fetch_optional(&self.pool)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called on `QueryAs<'_, _, models::User, _>` due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/models.rs:10:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub struct User {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `models::User: FromRow<'r, _>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/uuid-1.18.1/src/lib.rs:459:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub struct Uuid(Bytes);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `Uuid: Type<_>` or `Uuid: sqlx::Decode<'_, _>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `Uuid: Type<_>`\u001b[0m\n\u001b[0m            `Uuid: sqlx::Decode<'_, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Uuid: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1996,"byte_end":2000,"line_start":67,"line_end":67,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"        let user = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE id = $1\")","highlight_start":40,"highlight_end":44}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Uuid`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 48 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::User` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models.rs","byte_start":171,"byte_end":184,"line_start":9,"line_end":9,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models.rs","byte_start":171,"byte_end":184,"line_start":9,"line_end":9,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models.rs","byte_start":198,"byte_end":202,"line_start":10,"line_end":10,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct User {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Uuid: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:67:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m67\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let user = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE id = $1\")\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `sqlx::Decode<'_, _>` is not implemented for `Uuid`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\u001b[0m\n\u001b[0m              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\u001b[0m\n\u001b[0m              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\u001b[0m\n\u001b[0m              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\u001b[0m\n\u001b[0m              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\u001b[0m\n\u001b[0m              `&'r str` implements `sqlx::Decode<'r, Postgres>`\u001b[0m\n\u001b[0m              `()` implements `sqlx::Decode<'r, Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\u001b[0m\n\u001b[0m            and 48 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `models::User` to implement `for<'r> FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/models.rs:9:48\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct User {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m342\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m345\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Uuid: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1996,"byte_end":2000,"line_start":67,"line_end":67,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"        let user = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE id = $1\")","highlight_start":40,"highlight_end":44}],"label":"the trait `Type<_>` is not implemented for `Uuid`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::User` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models.rs","byte_start":171,"byte_end":184,"line_start":9,"line_end":9,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models.rs","byte_start":171,"byte_end":184,"line_start":9,"line_end":9,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models.rs","byte_start":198,"byte_end":202,"line_start":10,"line_end":10,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"pub struct User {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Uuid: Type<_>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:67:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m67\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let user = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE id = $1\")\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Type<_>` is not implemented for `Uuid`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Type<DB>`:\u001b[0m\n\u001b[0m              `&T` implements `Type<DB>`\u001b[0m\n\u001b[0m              `()` implements `Type<Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2, T3)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2, T3, T4)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m            and 50 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `models::User` to implement `for<'r> FromRow<'r, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/models.rs:9:48\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct User {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `sqlx::query_as`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m342\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m345\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    O: for<'r> FromRow<'r, DB::Row>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `query_as`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Uuid: Encode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":2057,"byte_end":2064,"line_start":68,"line_end":68,"column_start":19,"column_end":26,"is_primary":true,"text":[{"text":"            .bind(user_id)","highlight_start":19,"highlight_end":26}],"label":"the trait `Encode<'_, _>` is not implemented for `Uuid`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/db.rs","byte_start":2052,"byte_end":2056,"line_start":68,"line_end":68,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"            .bind(user_id)","highlight_start":14,"highlight_end":18}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `&'a str` implements `Encode<'a, sqlx::Any>`\n  `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n  `&T` implements `Encode<'q, DB>`\n  `&[T]` implements `Encode<'q, Postgres>`\n  `&[u8]` implements `Encode<'_, Postgres>`\n  `&str` implements `Encode<'_, Postgres>`\n  `Box<[u8]>` implements `Encode<'_, Postgres>`\n  `Box<str>` implements `Encode<'_, Postgres>`\nand 40 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Uuid: Encode<'_, _>` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:68:19\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .bind(user_id)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Encode<'_, _>` is not implemented for `Uuid`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\u001b[0m\n\u001b[0m             `&'a str` implements `Encode<'a, sqlx::Any>`\u001b[0m\n\u001b[0m             `&'q [u8]` implements `Encode<'q, sqlx::Any>`\u001b[0m\n\u001b[0m             `&T` implements `Encode<'q, DB>`\u001b[0m\n\u001b[0m             `&[T]` implements `Encode<'q, Postgres>`\u001b[0m\n\u001b[0m             `&[u8]` implements `Encode<'_, Postgres>`\u001b[0m\n\u001b[0m             `&str` implements `Encode<'_, Postgres>`\u001b[0m\n\u001b[0m             `Box<[u8]>` implements `Encode<'_, Postgres>`\u001b[0m\n\u001b[0m             `Box<str>` implements `Encode<'_, Postgres>`\u001b[0m\n\u001b[0m           and 40 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Uuid: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":2057,"byte_end":2064,"line_start":68,"line_end":68,"column_start":19,"column_end":26,"is_primary":true,"text":[{"text":"            .bind(user_id)","highlight_start":19,"highlight_end":26}],"label":"the trait `Type<_>` is not implemented for `Uuid`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/db.rs","byte_start":2052,"byte_end":2056,"line_start":68,"line_end":68,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"            .bind(user_id)","highlight_start":14,"highlight_end":18}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1583,"byte_end":1591,"line_start":54,"line_end":54,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":49,"highlight_end":57}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use a unary tuple instead","code":null,"level":"help","spans":[{"file_name":"src/db.rs","byte_start":2057,"byte_end":2057,"line_start":68,"line_end":68,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"            .bind(user_id)","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/db.rs","byte_start":2064,"byte_end":2064,"line_start":68,"line_end":68,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"            .bind(user_id)","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":",)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Uuid: Type<_>` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:68:19\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .bind(user_id)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Type<_>` is not implemented for `Uuid`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Type<DB>`:\u001b[0m\n\u001b[0m             `&T` implements `Type<DB>`\u001b[0m\n\u001b[0m             `()` implements `Type<Postgres>`\u001b[0m\n\u001b[0m             `(T1, T2)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m             `(T1, T2, T3)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m             `(T1, T2, T3, T4)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m             `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m             `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m             `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m           and 50 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:49\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use a unary tuple instead\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            .bind(\u001b[0m\u001b[0m\u001b[38;5;10m(\u001b[0m\u001b[0muser_id\u001b[0m\u001b[0m\u001b[38;5;10m,)\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_optional` exists for struct `QueryAs<'_, _, models::User, _>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1976,"byte_end":2079,"line_start":67,"line_end":69,"column_start":20,"column_end":14,"is_primary":false,"text":[{"text":"        let user = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE id = $1\")","highlight_start":20,"highlight_end":82},{"text":"            .bind(user_id)","highlight_start":1,"highlight_end":27},{"text":"            .fetch_optional(&self.pool)","highlight_start":1,"highlight_end":14}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/db.rs","byte_start":2079,"byte_end":2093,"line_start":69,"line_end":69,"column_start":14,"column_end":28,"is_primary":true,"text":[{"text":"            .fetch_optional(&self.pool)","highlight_start":14,"highlight_end":28}],"label":"method cannot be called on `QueryAs<'_, _, models::User, _>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models.rs","byte_start":187,"byte_end":202,"line_start":10,"line_end":10,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub struct User {","highlight_start":1,"highlight_end":16}],"label":"doesn't satisfy `models::User: FromRow<'r, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/uuid-1.18.1/src/lib.rs","byte_start":13742,"byte_end":13757,"line_start":459,"line_end":459,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"pub struct Uuid(Bytes);","highlight_start":1,"highlight_end":16}],"label":"doesn't satisfy `Uuid: Type<_>` or `Uuid: sqlx::Decode<'_, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Uuid: Type<_>`\n`Uuid: sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: the method `fetch_optional` exists for struct `QueryAs<'_, _, models::User, _>`, but its trait bounds were not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:69:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m67\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let user = sqlx::query_as::<_, User>(\"SELECT * FROM users WHERE id = $1\")\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ____________________-\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m68\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .bind(user_id)\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m69\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .fetch_optional(&self.pool)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod cannot be called on `QueryAs<'_, _, models::User, _>` due to unsatisfied trait bounds\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/models.rs:10:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub struct User {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `models::User: FromRow<'r, _>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/uuid-1.18.1/src/lib.rs:459:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub struct Uuid(Bytes);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mdoesn't satisfy `Uuid: Type<_>` or `Uuid: sqlx::Decode<'_, _>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m            `Uuid: Type<_>`\u001b[0m\n\u001b[0m            `Uuid: sqlx::Decode<'_, _>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Uuid: Encode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":2403,"byte_end":2410,"line_start":78,"line_end":78,"column_start":19,"column_end":26,"is_primary":true,"text":[{"text":"            .bind(user_id)","highlight_start":19,"highlight_end":26}],"label":"the trait `Encode<'_, _>` is not implemented for `Uuid`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/db.rs","byte_start":2398,"byte_end":2402,"line_start":78,"line_end":78,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"            .bind(user_id)","highlight_start":14,"highlight_end":18}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `&'a str` implements `Encode<'a, sqlx::Any>`\n  `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n  `&T` implements `Encode<'q, DB>`\n  `&[T]` implements `Encode<'q, Postgres>`\n  `&[u8]` implements `Encode<'_, Postgres>`\n  `&str` implements `Encode<'_, Postgres>`\n  `Box<[u8]>` implements `Encode<'_, Postgres>`\n  `Box<str>` implements `Encode<'_, Postgres>`\nand 40 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query::Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query.rs","byte_start":2937,"byte_end":2951,"line_start":81,"line_end":81,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Uuid: Encode<'_, _>` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:78:19\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .bind(user_id)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Encode<'_, _>` is not implemented for `Uuid`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\u001b[0m\n\u001b[0m             `&'a str` implements `Encode<'a, sqlx::Any>`\u001b[0m\n\u001b[0m             `&'q [u8]` implements `Encode<'q, sqlx::Any>`\u001b[0m\n\u001b[0m             `&T` implements `Encode<'q, DB>`\u001b[0m\n\u001b[0m             `&[T]` implements `Encode<'q, Postgres>`\u001b[0m\n\u001b[0m             `&[u8]` implements `Encode<'_, Postgres>`\u001b[0m\n\u001b[0m             `&str` implements `Encode<'_, Postgres>`\u001b[0m\n\u001b[0m             `Box<[u8]>` implements `Encode<'_, Postgres>`\u001b[0m\n\u001b[0m             `Box<str>` implements `Encode<'_, Postgres>`\u001b[0m\n\u001b[0m           and 40 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `sqlx::query::Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query.rs:81:32\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m81\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Uuid: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":2403,"byte_end":2410,"line_start":78,"line_end":78,"column_start":19,"column_end":26,"is_primary":true,"text":[{"text":"            .bind(user_id)","highlight_start":19,"highlight_end":26}],"label":"the trait `Type<_>` is not implemented for `Uuid`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/db.rs","byte_start":2398,"byte_end":2402,"line_start":78,"line_end":78,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"            .bind(user_id)","highlight_start":14,"highlight_end":18}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query::Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query.rs","byte_start":2954,"byte_end":2962,"line_start":81,"line_end":81,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":49,"highlight_end":57}],"label":"required by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use a unary tuple instead","code":null,"level":"help","spans":[{"file_name":"src/db.rs","byte_start":2403,"byte_end":2403,"line_start":78,"line_end":78,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"            .bind(user_id)","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/db.rs","byte_start":2410,"byte_end":2410,"line_start":78,"line_end":78,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"            .bind(user_id)","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":",)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Uuid: Type<_>` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:78:19\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .bind(user_id)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Type<_>` is not implemented for `Uuid`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Type<DB>`:\u001b[0m\n\u001b[0m             `&T` implements `Type<DB>`\u001b[0m\n\u001b[0m             `()` implements `Type<Postgres>`\u001b[0m\n\u001b[0m             `(T1, T2)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m             `(T1, T2, T3)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m             `(T1, T2, T3, T4)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m             `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m             `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m             `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\u001b[0m\n\u001b[0m           and 50 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `sqlx::query::Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query.rs:81:49\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m81\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use a unary tuple instead\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            .bind(\u001b[0m\u001b[0m\u001b[38;5;10m(\u001b[0m\u001b[0muser_id\u001b[0m\u001b[0m\u001b[38;5;10m,)\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 1 argument but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/handlers/users.rs","byte_start":3198,"byte_end":3208,"line_start":114,"line_end":114,"column_start":50,"column_end":60,"is_primary":false,"text":[{"text":"        let cookie = Cookie::build(\"session_id\", session_id)","highlight_start":50,"highlight_end":60}],"label":"unexpected argument #2 of type `std::string::String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/users.rs","byte_start":3170,"byte_end":3183,"line_start":114,"line_end":114,"column_start":22,"column_end":35,"is_primary":true,"text":[{"text":"        let cookie = Cookie::build(\"session_id\", session_id)","highlight_start":22,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cookie-0.18.1/src/lib.rs","byte_start":10859,"byte_end":10864,"line_start":327,"line_end":327,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"    pub fn build<C: Into<Cookie<'c>>>(base: C) -> CookieBuilder<'c> {","highlight_start":12,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra argument","code":null,"level":"help","spans":[{"file_name":"src/handlers/users.rs","byte_start":3196,"byte_end":3208,"line_start":114,"line_end":114,"column_start":48,"column_end":60,"is_primary":true,"text":[{"text":"        let cookie = Cookie::build(\"session_id\", session_id)","highlight_start":48,"highlight_end":60}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 1 argument but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:114:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let cookie = Cookie::build(\"session_id\", session_id)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12munexpected argument #2 of type `std::string::String`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cookie-0.18.1/src/lib.rs:327:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m327\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn build<C: Into<Cookie<'c>>>(base: C) -> CookieBuilder<'c> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the extra argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        let cookie = Cookie::build(\"session_id\"\u001b[0m\u001b[0m\u001b[38;5;9m, session_id\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        let cookie = Cookie::build(\"session_id\")\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `cookie::CookieBuilder::<'c>::finish`: `CookieBuilder` can be passed in to methods expecting a `Cookie`; for other cases, use `CookieBuilder::build()`","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/users.rs","byte_start":3385,"byte_end":3391,"line_start":119,"line_end":119,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"            .finish();","highlight_start":14,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(deprecated)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: use of deprecated method `cookie::CookieBuilder::<'c>::finish`: `CookieBuilder` can be passed in to methods expecting a `Cookie`; for other cases, use `CookieBuilder::build()`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:119:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m119\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .finish();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(deprecated)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/handlers/users.rs","byte_start":4535,"byte_end":4542,"line_start":164,"line_end":164,"column_start":17,"column_end":24,"is_primary":true,"text":[{"text":"            id: user.id,","highlight_start":17,"highlight_end":24}],"label":"expected `i64`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:164:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m164\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            id: user.id,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `i64`, found `()`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 1 argument but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/handlers/users.rs","byte_start":5428,"byte_end":5430,"line_start":201,"line_end":201,"column_start":46,"column_end":48,"is_primary":false,"text":[{"text":"    let cookie = Cookie::build(\"session_id\", \"\")","highlight_start":46,"highlight_end":48}],"label":"unexpected argument #2 of type `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/users.rs","byte_start":5400,"byte_end":5413,"line_start":201,"line_end":201,"column_start":18,"column_end":31,"is_primary":true,"text":[{"text":"    let cookie = Cookie::build(\"session_id\", \"\")","highlight_start":18,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cookie-0.18.1/src/lib.rs","byte_start":10859,"byte_end":10864,"line_start":327,"line_end":327,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"    pub fn build<C: Into<Cookie<'c>>>(base: C) -> CookieBuilder<'c> {","highlight_start":12,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra argument","code":null,"level":"help","spans":[{"file_name":"src/handlers/users.rs","byte_start":5426,"byte_end":5430,"line_start":201,"line_end":201,"column_start":44,"column_end":48,"is_primary":true,"text":[{"text":"    let cookie = Cookie::build(\"session_id\", \"\")","highlight_start":44,"highlight_end":48}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 1 argument but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:201:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m201\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let cookie = Cookie::build(\"session_id\", \"\")\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12munexpected argument #2 of type `&'static str`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/cookie-0.18.1/src/lib.rs:327:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m327\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn build<C: Into<Cookie<'c>>>(base: C) -> CookieBuilder<'c> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: remove the extra argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m201\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m    let cookie = Cookie::build(\"session_id\"\u001b[0m\u001b[0m\u001b[38;5;9m, \"\"\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m201\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m    let cookie = Cookie::build(\"session_id\")\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `cookie::CookieBuilder::<'c>::finish`: `CookieBuilder` can be passed in to methods expecting a `Cookie`; for other cases, use `CookieBuilder::build()`","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/users.rs","byte_start":5552,"byte_end":5558,"line_start":206,"line_end":206,"column_start":10,"column_end":16,"is_primary":true,"text":[{"text":"        .finish();","highlight_start":10,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: use of deprecated method `cookie::CookieBuilder::<'c>::finish`: `CookieBuilder` can be passed in to methods expecting a `Cookie`; for other cases, use `CookieBuilder::build()`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/handlers/users.rs:206:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .finish();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `sessions` on type `&AppState`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/middleware.rs","byte_start":800,"byte_end":808,"line_start":29,"line_end":29,"column_start":37,"column_end":45,"is_primary":true,"text":[{"text":"                let sessions = &ctx.sessions; // Or anyting else to authenticate.","highlight_start":37,"highlight_end":45}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `db`, `session_store`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0609]\u001b[0m\u001b[0m\u001b[1m: no field `sessions` on type `&AppState`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/middleware.rs:29:37\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                let sessions = &ctx.sessions; // Or anyting else to authenticate.\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munknown field\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: available fields are: `db`, `session_store`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `ApiError`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/middleware.rs","byte_start":984,"byte_end":992,"line_start":34,"line_end":34,"column_start":25,"column_end":33,"is_primary":true,"text":[{"text":"                    Err(ApiError::AccesDenied)","highlight_start":25,"highlight_end":33}],"label":"use of undeclared type `ApiError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `ApiError`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/middleware.rs:34:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Err(ApiError::AccesDenied)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `ApiError`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of undeclared type `ApiError`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/middleware.rs","byte_start":1063,"byte_end":1071,"line_start":37,"line_end":37,"column_start":25,"column_end":33,"is_primary":true,"text":[{"text":"            None => Err(ApiError::CookieNotProvided),","highlight_start":25,"highlight_end":33}],"label":"use of undeclared type `ApiError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `ApiError`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/middleware.rs:37:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            None => Err(ApiError::CookieNotProvided),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `ApiError`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `redis_conn` found for struct `Arc<AppState>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/middleware.rs","byte_start":1865,"byte_end":1875,"line_start":64,"line_end":64,"column_start":29,"column_end":39,"is_primary":true,"text":[{"text":"        let mut con = state.redis_conn().await;","highlight_start":29,"highlight_end":39}],"label":"method not found in `Arc<AppState>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `redis_conn` found for struct `Arc<AppState>` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/middleware.rs:64:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m64\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut con = state.redis_conn().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `Arc<AppState>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/store/user_store.rs","byte_start":445,"byte_end":450,"line_start":16,"line_end":16,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"        Ok(id) => return Ok(id.id),","highlight_start":29,"highlight_end":34}],"label":"expected `i64`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/store/user_store.rs","byte_start":442,"byte_end":444,"line_start":16,"line_end":16,"column_start":26,"column_end":28,"is_primary":false,"text":[{"text":"        Ok(id) => return Ok(id.id),","highlight_start":26,"highlight_end":28}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `()` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"src/store/user_store.rs","byte_start":445,"byte_end":450,"line_start":16,"line_end":16,"column_start":29,"column_end":34,"is_primary":false,"text":[{"text":"        Ok(id) => return Ok(id.id),","highlight_start":29,"highlight_end":34}],"label":"this argument influences the type of `Ok`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/store/user_store.rs","byte_start":442,"byte_end":451,"line_start":16,"line_end":16,"column_start":26,"column_end":35,"is_primary":true,"text":[{"text":"        Ok(id) => return Ok(id.id),","highlight_start":26,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/home/marc/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":20921,"byte_end":20923,"line_start":552,"line_end":552,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/store/user_store.rs:16:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Ok(id) => return Ok(id.id),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `i64`, found `()`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this enum variant are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: the type constructed contains `()` due to the type of the argument passed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/store/user_store.rs:16:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Ok(id) => return Ok(id.id),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis argument influences the type of `Ok`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: tuple variant defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:552:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m552\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `ping` found for struct `MultiplexedConnection` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/auth.rs","byte_start":727,"byte_end":731,"line_start":30,"line_end":30,"column_start":30,"column_end":34,"is_primary":true,"text":[{"text":"        let _: String = conn.ping().await?;","highlight_start":30,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `xpending` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/macros.rs","byte_start":6752,"byte_end":7021,"line_start":162,"line_end":167,"column_start":17,"column_end":40,"is_primary":true,"text":[{"text":"                fn $name<$lifetime, $($tyargs: $ty + Send + Sync + $lifetime,)* RV>(","highlight_start":17,"highlight_end":85},{"text":"                    & $lifetime mut self","highlight_start":1,"highlight_end":41},{"text":"                    $(, $argname: $argty)*","highlight_start":1,"highlight_end":43},{"text":"                ) -> crate::types::RedisFuture<'a, RV>","highlight_start":1,"highlight_end":55},{"text":"                where","highlight_start":1,"highlight_end":22},{"text":"                    RV: FromRedisValue,","highlight_start":1,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/mod.rs","byte_start":2151,"byte_end":64581,"line_start":41,"line_end":1847,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"implement_commands! {","highlight_start":1,"highlight_end":1},{"text":"    'a","highlight_start":1,"highlight_end":1},{"text":"    // most common operations","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key.  If key is a vec this becomes an `MGET`.","highlight_start":1,"highlight_end":1},{"text":"    fn get<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(if key.is_single_arg() { \"GET\" } else { \"MGET\" }).arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get values of keys","highlight_start":1,"highlight_end":1},{"text":"    fn mget<K: ToRedisArgs>(key: K){","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"MGET\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all keys matching pattern","highlight_start":1,"highlight_end":1},{"text":"    fn keys<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"KEYS\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn set<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SET\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key with options.","highlight_start":1,"highlight_end":1},{"text":"    fn set_options<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, options: SetOptions) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SET\").arg(key).arg(value).arg(options)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values.","highlight_start":1,"highlight_end":1},{"text":"    #[allow(deprecated)]","highlight_start":1,"highlight_end":1},{"text":"    #[deprecated(since = \"0.22.4\", note = \"Renamed to mset() to reflect Redis name\")]","highlight_start":1,"highlight_end":1},{"text":"    fn set_multiple<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"MSET\").arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values.","highlight_start":1,"highlight_end":1},{"text":"    fn mset<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"MSET\").arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value and expiration of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn set_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, seconds: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SETEX\").arg(key).arg(seconds).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value and expiration in milliseconds of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn pset_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, milliseconds: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PSETEX\").arg(key).arg(milliseconds).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value of a key, only if the key does not exist","highlight_start":1,"highlight_end":1},{"text":"    fn set_nx<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SETNX\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values failing if at least one already exists.","highlight_start":1,"highlight_end":1},{"text":"    fn mset_nx<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"MSETNX\").arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key and return its old value.","highlight_start":1,"highlight_end":1},{"text":"    fn getset<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GETSET\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get a range of bytes/substring from the value of a key. Negative values provide an offset from the end of the value.","highlight_start":1,"highlight_end":1},{"text":"    fn getrange<K: ToRedisArgs>(key: K, from: isize, to: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GETRANGE\").arg(key).arg(from).arg(to)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Overwrite the part of the value stored in key at the specified offset.","highlight_start":1,"highlight_end":1},{"text":"    fn setrange<K: ToRedisArgs, V: ToRedisArgs>(key: K, offset: isize, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SETRANGE\").arg(key).arg(offset).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Delete one or more keys.","highlight_start":1,"highlight_end":1},{"text":"    fn del<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"DEL\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine if a key exists.","highlight_start":1,"highlight_end":1},{"text":"    fn exists<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"EXISTS\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the type of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn key_type<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"TYPE\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set a key's time to live in seconds.","highlight_start":1,"highlight_end":1},{"text":"    fn expire<K: ToRedisArgs>(key: K, seconds: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"EXPIRE\").arg(key).arg(seconds)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the expiration for a key as a UNIX timestamp.","highlight_start":1,"highlight_end":1},{"text":"    fn expire_at<K: ToRedisArgs>(key: K, ts: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"EXPIREAT\").arg(key).arg(ts)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set a key's time to live in milliseconds.","highlight_start":1,"highlight_end":1},{"text":"    fn pexpire<K: ToRedisArgs>(key: K, ms: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PEXPIRE\").arg(key).arg(ms)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the expiration for a key as a UNIX timestamp in milliseconds.","highlight_start":1,"highlight_end":1},{"text":"    fn pexpire_at<K: ToRedisArgs>(key: K, ts: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PEXPIREAT\").arg(key).arg(ts)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove the expiration from a key.","highlight_start":1,"highlight_end":1},{"text":"    fn persist<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PERSIST\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the expiration time of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn ttl<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"TTL\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the expiration time of a key in milliseconds.","highlight_start":1,"highlight_end":1},{"text":"    fn pttl<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PTTL\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key and set expiration","highlight_start":1,"highlight_end":1},{"text":"    fn get_ex<K: ToRedisArgs>(key: K, expire_at: Expiry) {","highlight_start":1,"highlight_end":1},{"text":"        let (option, time_arg) = match expire_at {","highlight_start":1,"highlight_end":1},{"text":"            Expiry::EX(sec) => (\"EX\", Some(sec)),","highlight_start":1,"highlight_end":1},{"text":"            Expiry::PX(ms) => (\"PX\", Some(ms)),","highlight_start":1,"highlight_end":1},{"text":"            Expiry::EXAT(timestamp_sec) => (\"EXAT\", Some(timestamp_sec)),","highlight_start":1,"highlight_end":1},{"text":"            Expiry::PXAT(timestamp_ms) => (\"PXAT\", Some(timestamp_ms)),","highlight_start":1,"highlight_end":1},{"text":"            Expiry::PERSIST => (\"PERSIST\", None),","highlight_start":1,"highlight_end":1},{"text":"        };","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GETEX\").arg(key).arg(option).arg(time_arg)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key and delete it","highlight_start":1,"highlight_end":1},{"text":"    fn get_del<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GETDEL\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Rename a key.","highlight_start":1,"highlight_end":1},{"text":"    fn rename<K: ToRedisArgs, N: ToRedisArgs>(key: K, new_key: N) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"RENAME\").arg(key).arg(new_key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Rename a key, only if the new key does not exist.","highlight_start":1,"highlight_end":1},{"text":"    fn rename_nx<K: ToRedisArgs, N: ToRedisArgs>(key: K, new_key: N) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"RENAMENX\").arg(key).arg(new_key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unlink one or more keys.","highlight_start":1,"highlight_end":1},{"text":"    fn unlink<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"UNLINK\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // common string operations","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Append a value to a key.","highlight_start":1,"highlight_end":1},{"text":"    fn append<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"APPEND\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increment the numeric value of a key by the given amount.  This","highlight_start":1,"highlight_end":1},{"text":"    /// issues a `INCRBY` or `INCRBYFLOAT` depending on the type.","highlight_start":1,"highlight_end":1},{"text":"    fn incr<K: ToRedisArgs, V: ToRedisArgs>(key: K, delta: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(if delta.describe_numeric_behavior() == NumericBehavior::NumberIsFloat {","highlight_start":1,"highlight_end":1},{"text":"            \"INCRBYFLOAT\"","highlight_start":1,"highlight_end":1},{"text":"        } else {","highlight_start":1,"highlight_end":1},{"text":"            \"INCRBY\"","highlight_start":1,"highlight_end":1},{"text":"        }).arg(key).arg(delta)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Decrement the numeric value of a key by the given amount.","highlight_start":1,"highlight_end":1},{"text":"    fn decr<K: ToRedisArgs, V: ToRedisArgs>(key: K, delta: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"DECRBY\").arg(key).arg(delta)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets or clears the bit at offset in the string value stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn setbit<K: ToRedisArgs>(key: K, offset: usize, value: bool) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SETBIT\").arg(key).arg(offset).arg(i32::from(value))","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the bit value at offset in the string value stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn getbit<K: ToRedisArgs>(key: K, offset: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GETBIT\").arg(key).arg(offset)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count set bits in a string.","highlight_start":1,"highlight_end":1},{"text":"    fn bitcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BITCOUNT\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count set bits in a string in a range.","highlight_start":1,"highlight_end":1},{"text":"    fn bitcount_range<K: ToRedisArgs>(key: K, start: usize, end: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BITCOUNT\").arg(key).arg(start).arg(end)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise AND between multiple keys (containing string values)","highlight_start":1,"highlight_end":1},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":1},{"text":"    fn bit_and<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BITOP\").arg(\"AND\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise OR between multiple keys (containing string values)","highlight_start":1,"highlight_end":1},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":1},{"text":"    fn bit_or<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BITOP\").arg(\"OR\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise XOR between multiple keys (containing string values)","highlight_start":1,"highlight_end":1},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":1},{"text":"    fn bit_xor<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BITOP\").arg(\"XOR\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise NOT of the key (containing string values)","highlight_start":1,"highlight_end":1},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":1},{"text":"    fn bit_not<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckey: S) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BITOP\").arg(\"NOT\").arg(dstkey).arg(srckey)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the length of the value stored in a key.","highlight_start":1,"highlight_end":1},{"text":"    fn strlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"STRLEN\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // hash operations","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets a single (or multiple) fields from a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hget<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(if field.is_single_arg() { \"HGET\" } else { \"HMGET\" }).arg(key).arg(field)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Deletes a single (or multiple) fields from a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hdel<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HDEL\").arg(key).arg(field)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a single field in a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hset<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, field: F, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HSET\").arg(key).arg(field).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a single field in a hash if it does not exist.","highlight_start":1,"highlight_end":1},{"text":"    fn hset_nx<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, field: F, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HSETNX\").arg(key).arg(field).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a multiple fields in a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hset_multiple<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, items: &'a [(F, V)]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HMSET\").arg(key).arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increments a value.","highlight_start":1,"highlight_end":1},{"text":"    fn hincr<K: ToRedisArgs, F: ToRedisArgs, D: ToRedisArgs>(key: K, field: F, delta: D) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(if delta.describe_numeric_behavior() == NumericBehavior::NumberIsFloat {","highlight_start":1,"highlight_end":1},{"text":"            \"HINCRBYFLOAT\"","highlight_start":1,"highlight_end":1},{"text":"        } else {","highlight_start":1,"highlight_end":1},{"text":"            \"HINCRBY\"","highlight_start":1,"highlight_end":1},{"text":"        }).arg(key).arg(field).arg(delta)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Checks if a field in a hash exists.","highlight_start":1,"highlight_end":1},{"text":"    fn hexists<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HEXISTS\").arg(key).arg(field)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the keys in a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hkeys<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HKEYS\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the values in a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hvals<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HVALS\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the fields and values in a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hgetall<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HGETALL\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets the length of a hash.","highlight_start":1,"highlight_end":1},{"text":"    fn hlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"HLEN\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // list operations","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop an element from a list, push it to another list","highlight_start":1,"highlight_end":1},{"text":"    /// and return it; or block until one is available","highlight_start":1,"highlight_end":1},{"text":"    fn blmove<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, src_dir: Direction, dst_dir: Direction, timeout: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BLMOVE\").arg(srckey).arg(dstkey).arg(src_dir).arg(dst_dir).arg(timeout)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pops `count` elements from the first non-empty list key from the list of","highlight_start":1,"highlight_end":1},{"text":"    /// provided key names; or blocks until one is available.","highlight_start":1,"highlight_end":1},{"text":"    fn blmpop<K: ToRedisArgs>(timeout: usize, numkeys: usize, key: K, dir: Direction, count: usize){","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BLMPOP\").arg(timeout).arg(numkeys).arg(key).arg(dir).arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and get the first element in a list, or block until one is available.","highlight_start":1,"highlight_end":1},{"text":"    fn blpop<K: ToRedisArgs>(key: K, timeout: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BLPOP\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and get the last element in a list, or block until one is available.","highlight_start":1,"highlight_end":1},{"text":"    fn brpop<K: ToRedisArgs>(key: K, timeout: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BRPOP\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop a value from a list, push it to another list and return it;","highlight_start":1,"highlight_end":1},{"text":"    /// or block until one is available.","highlight_start":1,"highlight_end":1},{"text":"    fn brpoplpush<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, timeout: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"BRPOPLPUSH\").arg(srckey).arg(dstkey).arg(timeout)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get an element from a list by its index.","highlight_start":1,"highlight_end":1},{"text":"    fn lindex<K: ToRedisArgs>(key: K, index: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LINDEX\").arg(key).arg(index)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert an element before another element in a list.","highlight_start":1,"highlight_end":1},{"text":"    fn linsert_before<K: ToRedisArgs, P: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"            key: K, pivot: P, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LINSERT\").arg(key).arg(\"BEFORE\").arg(pivot).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert an element after another element in a list.","highlight_start":1,"highlight_end":1},{"text":"    fn linsert_after<K: ToRedisArgs, P: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"            key: K, pivot: P, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LINSERT\").arg(key).arg(\"AFTER\").arg(pivot).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the length of the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn llen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LLEN\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop an element a list, push it to another list and return it","highlight_start":1,"highlight_end":1},{"text":"    fn lmove<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, src_dir: Direction, dst_dir: Direction) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LMOVE\").arg(srckey).arg(dstkey).arg(src_dir).arg(dst_dir)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pops `count` elements from the first non-empty list key from the list of","highlight_start":1,"highlight_end":1},{"text":"    /// provided key names.","highlight_start":1,"highlight_end":1},{"text":"    fn lmpop<K: ToRedisArgs>( numkeys: usize, key: K, dir: Direction, count: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LMPOP\").arg(numkeys).arg(key).arg(dir).arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the up to `count` first elements of the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// If `count` is not specified, then defaults to first element.","highlight_start":1,"highlight_end":1},{"text":"    fn lpop<K: ToRedisArgs>(key: K, count: Option<core::num::NonZeroUsize>) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LPOP\").arg(key).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the index of the first matching value of the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn lpos<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, options: LposOptions) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LPOS\").arg(key).arg(value).arg(options)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert all the specified values at the head of the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn lpush<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LPUSH\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Inserts a value at the head of the list stored at key, only if key","highlight_start":1,"highlight_end":1},{"text":"    /// already exists and holds a list.","highlight_start":1,"highlight_end":1},{"text":"    fn lpush_exists<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LPUSHX\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the specified elements of the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn lrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes the first count occurrences of elements equal to value","highlight_start":1,"highlight_end":1},{"text":"    /// from the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn lrem<K: ToRedisArgs, V: ToRedisArgs>(key: K, count: isize, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LREM\").arg(key).arg(count).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Trim an existing list so that it will contain only the specified","highlight_start":1,"highlight_end":1},{"text":"    /// range of elements specified.","highlight_start":1,"highlight_end":1},{"text":"    fn ltrim<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LTRIM\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets the list element at index to value","highlight_start":1,"highlight_end":1},{"text":"    fn lset<K: ToRedisArgs, V: ToRedisArgs>(key: K, index: isize, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"LSET\").arg(key).arg(index).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the up to `count` last elements of the list stored at key","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// If `count` is not specified, then defaults to last element.","highlight_start":1,"highlight_end":1},{"text":"    fn rpop<K: ToRedisArgs>(key: K, count: Option<core::num::NonZeroUsize>) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"RPOP\").arg(key).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop a value from a list, push it to another list and return it.","highlight_start":1,"highlight_end":1},{"text":"    fn rpoplpush<K: ToRedisArgs, D: ToRedisArgs>(key: K, dstkey: D) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"RPOPLPUSH\").arg(key).arg(dstkey)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert all the specified values at the tail of the list stored at key.","highlight_start":1,"highlight_end":1},{"text":"    fn rpush<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"RPUSH\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Inserts value at the tail of the list stored at key, only if key","highlight_start":1,"highlight_end":1},{"text":"    /// already exists and holds a list.","highlight_start":1,"highlight_end":1},{"text":"    fn rpush_exists<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"RPUSHX\").arg(key).arg(value)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // set commands","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add one or more members to a set.","highlight_start":1,"highlight_end":1},{"text":"    fn sadd<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SADD\").arg(key).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the number of members in a set.","highlight_start":1,"highlight_end":1},{"text":"    fn scard<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SCARD\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Subtract multiple sets.","highlight_start":1,"highlight_end":1},{"text":"    fn sdiff<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SDIFF\").arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Subtract multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":1},{"text":"    fn sdiffstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SDIFFSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sets.","highlight_start":1,"highlight_end":1},{"text":"    fn sinter<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SINTER\").arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":1},{"text":"    fn sinterstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SINTERSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine if a given value is a member of a set.","highlight_start":1,"highlight_end":1},{"text":"    fn sismember<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SISMEMBER\").arg(key).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get all the members in a set.","highlight_start":1,"highlight_end":1},{"text":"    fn smembers<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SMEMBERS\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Move a member from one set to another.","highlight_start":1,"highlight_end":1},{"text":"    fn smove<S: ToRedisArgs, D: ToRedisArgs, M: ToRedisArgs>(srckey: S, dstkey: D, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SMOVE\").arg(srckey).arg(dstkey).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and return a random member from a set.","highlight_start":1,"highlight_end":1},{"text":"    fn spop<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SPOP\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get one random member from a set.","highlight_start":1,"highlight_end":1},{"text":"    fn srandmember<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SRANDMEMBER\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get multiple random members from a set.","highlight_start":1,"highlight_end":1},{"text":"    fn srandmember_multiple<K: ToRedisArgs>(key: K, count: usize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SRANDMEMBER\").arg(key).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove one or more members from a set.","highlight_start":1,"highlight_end":1},{"text":"    fn srem<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SREM\").arg(key).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple sets.","highlight_start":1,"highlight_end":1},{"text":"    fn sunion<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SUNION\").arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":1},{"text":"    fn sunionstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"SUNIONSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // sorted set commands","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add one member to a sorted set, or update its score if it already exists.","highlight_start":1,"highlight_end":1},{"text":"    fn zadd<K: ToRedisArgs, S: ToRedisArgs, M: ToRedisArgs>(key: K, member: M, score: S) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZADD\").arg(key).arg(score).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple members to a sorted set, or update its score if it already exists.","highlight_start":1,"highlight_end":1},{"text":"    fn zadd_multiple<K: ToRedisArgs, S: ToRedisArgs, M: ToRedisArgs>(key: K, items: &'a [(S, M)]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZADD\").arg(key).arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the number of members in a sorted set.","highlight_start":1,"highlight_end":1},{"text":"    fn zcard<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZCARD\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count the members in a sorted set with scores within the given values.","highlight_start":1,"highlight_end":1},{"text":"    fn zcount<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZCOUNT\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increments the member in a sorted set at key by delta.","highlight_start":1,"highlight_end":1},{"text":"    /// If the member does not exist, it is added with delta as its score.","highlight_start":1,"highlight_end":1},{"text":"    fn zincr<K: ToRedisArgs, M: ToRedisArgs, D: ToRedisArgs>(key: K, member: M, delta: D) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINCRBY\").arg(key).arg(delta).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":1},{"text":"    /// a new key using SUM as aggregation function.","highlight_start":1,"highlight_end":1},{"text":"    fn zinterstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":1},{"text":"    /// a new key using MIN as aggregation function.","highlight_start":1,"highlight_end":1},{"text":"    fn zinterstore_min<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":1},{"text":"    /// a new key using MAX as aggregation function.","highlight_start":1,"highlight_end":1},{"text":"    fn zinterstore_max<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore`], but with the ability to specify a","highlight_start":1,"highlight_end":1},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":1},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":1},{"text":"    fn zinterstore_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":1},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore_min`], but with the ability to specify a","highlight_start":1,"highlight_end":1},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":1},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":1},{"text":"    fn zinterstore_min_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":1},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore_max`], but with the ability to specify a","highlight_start":1,"highlight_end":1},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":1},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":1},{"text":"    fn zinterstore_max_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":1},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count the number of members in a sorted set between a given lexicographical range.","highlight_start":1,"highlight_end":1},{"text":"    fn zlexcount<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZLEXCOUNT\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the highest scores in a sorted set","highlight_start":1,"highlight_end":1},{"text":"    fn zpopmax<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZPOPMAX\").arg(key).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the lowest scores in a sorted set","highlight_start":1,"highlight_end":1},{"text":"    fn zpopmin<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZPOPMIN\").arg(key).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the highest scores,","highlight_start":1,"highlight_end":1},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":1},{"text":"    fn zmpop_max<K: ToRedisArgs>(keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZMPOP\").arg(keys.len()).arg(keys).arg(\"MAX\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the lowest scores,","highlight_start":1,"highlight_end":1},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":1},{"text":"    fn zmpop_min<K: ToRedisArgs>(keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZMPOP\").arg(keys.len()).arg(keys).arg(\"MIN\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return up to count random members in a sorted set (or 1 if `count == None`)","highlight_start":1,"highlight_end":1},{"text":"    fn zrandmember<K: ToRedisArgs>(key: K, count: Option<isize>) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANDMEMBER\").arg(key).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return up to count random members in a sorted set with scores","highlight_start":1,"highlight_end":1},{"text":"    fn zrandmember_withscores<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANDMEMBER\").arg(key).arg(count).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index","highlight_start":1,"highlight_end":1},{"text":"    fn zrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index with scores.","highlight_start":1,"highlight_end":1},{"text":"    fn zrange_withscores<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGE\").arg(key).arg(start).arg(stop).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical range.","highlight_start":1,"highlight_end":1},{"text":"    fn zrangebylex<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGEBYLEX\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical","highlight_start":1,"highlight_end":1},{"text":"    /// range with offset and limit.","highlight_start":1,"highlight_end":1},{"text":"    fn zrangebylex_limit<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"            key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGEBYLEX\").arg(key).arg(min).arg(max).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical range.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrangebylex<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGEBYLEX\").arg(key).arg(max).arg(min)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical","highlight_start":1,"highlight_end":1},{"text":"    /// range with offset and limit.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrangebylex_limit<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"            key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGEBYLEX\").arg(key).arg(max).arg(min).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score.","highlight_start":1,"highlight_end":1},{"text":"    fn zrangebyscore<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with scores.","highlight_start":1,"highlight_end":1},{"text":"    fn zrangebyscore_withscores<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit.","highlight_start":1,"highlight_end":1},{"text":"    fn zrangebyscore_limit<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>","highlight_start":1,"highlight_end":1},{"text":"            (key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit with scores.","highlight_start":1,"highlight_end":1},{"text":"    fn zrangebyscore_limit_withscores<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>","highlight_start":1,"highlight_end":1},{"text":"            (key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the index of a member in a sorted set.","highlight_start":1,"highlight_end":1},{"text":"    fn zrank<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZRANK\").arg(key).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove one or more members from a sorted set.","highlight_start":1,"highlight_end":1},{"text":"    fn zrem<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREM\").arg(key).arg(members)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set between the given lexicographical range.","highlight_start":1,"highlight_end":1},{"text":"    fn zrembylex<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREMRANGEBYLEX\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set within the given indexes.","highlight_start":1,"highlight_end":1},{"text":"    fn zremrangebyrank<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREMRANGEBYRANK\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set within the given scores.","highlight_start":1,"highlight_end":1},{"text":"    fn zrembyscore<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREMRANGEBYSCORE\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index, with scores","highlight_start":1,"highlight_end":1},{"text":"    /// ordered from high to low.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index, with scores","highlight_start":1,"highlight_end":1},{"text":"    /// ordered from high to low.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrange_withscores<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGE\").arg(key).arg(start).arg(stop).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrangebyscore<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with scores.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrangebyscore_withscores<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrangebyscore_limit<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>","highlight_start":1,"highlight_end":1},{"text":"            (key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit with scores.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrangebyscore_limit_withscores<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>","highlight_start":1,"highlight_end":1},{"text":"            (key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the index of a member in a sorted set, with scores ordered from high to low.","highlight_start":1,"highlight_end":1},{"text":"    fn zrevrank<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZREVRANK\").arg(key).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the score associated with the given member in a sorted set.","highlight_start":1,"highlight_end":1},{"text":"    fn zscore<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZSCORE\").arg(key).arg(member)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the scores associated with multiple members in a sorted set.","highlight_start":1,"highlight_end":1},{"text":"    fn zscore_multiple<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: &'a [M]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZMSCORE\").arg(key).arg(members)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":1},{"text":"    /// a new key using SUM as aggregation function.","highlight_start":1,"highlight_end":1},{"text":"    fn zunionstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":1},{"text":"    /// a new key using MIN as aggregation function.","highlight_start":1,"highlight_end":1},{"text":"    fn zunionstore_min<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":1},{"text":"    /// a new key using MAX as aggregation function.","highlight_start":1,"highlight_end":1},{"text":"    fn zunionstore_max<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore`], but with the ability to specify a","highlight_start":1,"highlight_end":1},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":1},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":1},{"text":"    fn zunionstore_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":1},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore_min`], but with the ability to specify a","highlight_start":1,"highlight_end":1},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":1},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":1},{"text":"    fn zunionstore_min_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":1},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore_max`], but with the ability to specify a","highlight_start":1,"highlight_end":1},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":1},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":1},{"text":"    fn zunionstore_max_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":1},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // hyperloglog commands","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Adds the specified elements to the specified HyperLogLog.","highlight_start":1,"highlight_end":1},{"text":"    fn pfadd<K: ToRedisArgs, E: ToRedisArgs>(key: K, element: E) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PFADD\").arg(key).arg(element)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the approximated cardinality of the set(s) observed by the","highlight_start":1,"highlight_end":1},{"text":"    /// HyperLogLog at key(s).","highlight_start":1,"highlight_end":1},{"text":"    fn pfcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PFCOUNT\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Merge N different HyperLogLogs into a single one.","highlight_start":1,"highlight_end":1},{"text":"    fn pfmerge<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PFMERGE\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Posts a message to the given channel.","highlight_start":1,"highlight_end":1},{"text":"    fn publish<K: ToRedisArgs, E: ToRedisArgs>(channel: K, message: E) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"PUBLISH\").arg(channel).arg(message)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Object commands","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the encoding of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn object_encoding<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"OBJECT\").arg(\"ENCODING\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the time in seconds since the last access of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn object_idletime<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"OBJECT\").arg(\"IDLETIME\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the logarithmic access frequency counter of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn object_freq<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"OBJECT\").arg(\"FREQ\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the reference count of a key.","highlight_start":1,"highlight_end":1},{"text":"    fn object_refcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"OBJECT\").arg(\"REFCOUNT\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // ACL commands","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// When Redis is configured to use an ACL file (with the aclfile","highlight_start":1,"highlight_end":1},{"text":"    /// configuration option), this command will reload the ACLs from the file,","highlight_start":1,"highlight_end":1},{"text":"    /// replacing all the current ACL rules with the ones defined in the file.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_load<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"LOAD\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// When Redis is configured to use an ACL file (with the aclfile","highlight_start":1,"highlight_end":1},{"text":"    /// configuration option), this command will save the currently defined","highlight_start":1,"highlight_end":1},{"text":"    /// ACLs from the server memory to the ACL file.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_save<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"SAVE\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows the currently active ACL rules in the Redis server.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_list<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"LIST\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows a list of all the usernames of the currently configured users in","highlight_start":1,"highlight_end":1},{"text":"    /// the Redis ACL system.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_users<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"USERS\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns all the rules defined for an existing ACL user.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_getuser<K: ToRedisArgs>(username: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"GETUSER\").arg(username)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an ACL user without any privilege.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_setuser<K: ToRedisArgs>(username: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"SETUSER\").arg(username)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an ACL user with the specified rules or modify the rules of","highlight_start":1,"highlight_end":1},{"text":"    /// an existing user.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_setuser_rules<K: ToRedisArgs>(username: K, rules: &'a [acl::Rule]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"SETUSER\").arg(username).arg(rules)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Delete all the specified ACL users and terminate all the connections","highlight_start":1,"highlight_end":1},{"text":"    /// that are authenticated with such users.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_deluser<K: ToRedisArgs>(usernames: &'a [K]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"DELUSER\").arg(usernames)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows the available ACL categories.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_cat<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"CAT\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows all the Redis commands in the specified category.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_cat_categoryname<K: ToRedisArgs>(categoryname: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"CAT\").arg(categoryname)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Generates a 256-bits password starting from /dev/urandom if available.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_genpass<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"GENPASS\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Generates a 1-to-1024-bits password starting from /dev/urandom if available.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_genpass_bits<>(bits: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"GENPASS\").arg(bits)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the username the current connection is authenticated with.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_whoami<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"WHOAMI\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows a list of recent ACL security events","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_log<>(count: isize) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"LOG\").arg(count)","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Clears the ACL log.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_log_reset<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"LOG\").arg(\"RESET\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns a helpful text describing the different subcommands.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn acl_help<>() {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"ACL\").arg(\"HELP\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":1},{"text":"    // geospatial commands","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Adds the specified geospatial items to the specified key.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Every member has to be written as a tuple of `(longitude, latitude,","highlight_start":1,"highlight_end":1},{"text":"    /// member_name)`. It can be a single tuple, or a vector of tuples.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// `longitude, latitude` can be set using [`redis::geo::Coord`][1].","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [1]: ./geo/struct.Coord.html","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the number of elements added to the sorted set, not including","highlight_start":1,"highlight_end":1},{"text":"    /// elements already existing for which the score was updated.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Example","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Commands, Connection, RedisResult};","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::geo::Coord;","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn add_point(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":1},{"text":"    ///     con.geo_add(\"my_gis\", (Coord::lon_lat(13.361389, 38.115556), \"Palermo\"))","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn add_point_with_tuples(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":1},{"text":"    ///     con.geo_add(\"my_gis\", (\"13.361389\", \"38.115556\", \"Palermo\"))","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn add_many_points(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":1},{"text":"    ///     con.geo_add(\"my_gis\", &[","highlight_start":1,"highlight_end":1},{"text":"    ///         (\"13.361389\", \"38.115556\", \"Palermo\"),","highlight_start":1,"highlight_end":1},{"text":"    ///         (\"15.087269\", \"37.502669\", \"Catania\")","highlight_start":1,"highlight_end":1},{"text":"    ///     ])","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn geo_add<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GEOADD\").arg(key).arg(members)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the distance between two members in the geospatial index","highlight_start":1,"highlight_end":1},{"text":"    /// represented by the sorted set.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// If one or both the members are missing, the command returns NULL, so","highlight_start":1,"highlight_end":1},{"text":"    /// it may be convenient to parse its response as either `Option<f64>` or","highlight_start":1,"highlight_end":1},{"text":"    /// `Option<String>`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Example","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::geo::Unit;","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn get_dists(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":1},{"text":"    ///     let x: RedisResult<f64> = con.geo_dist(","highlight_start":1,"highlight_end":1},{"text":"    ///         \"my_gis\",","highlight_start":1,"highlight_end":1},{"text":"    ///         \"Palermo\",","highlight_start":1,"highlight_end":1},{"text":"    ///         \"Catania\",","highlight_start":1,"highlight_end":1},{"text":"    ///         Unit::Kilometers","highlight_start":1,"highlight_end":1},{"text":"    ///     );","highlight_start":1,"highlight_end":1},{"text":"    ///     // x is Ok(166.2742)","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    ///     let x: RedisResult<Option<f64>> = con.geo_dist(","highlight_start":1,"highlight_end":1},{"text":"    ///         \"my_gis\",","highlight_start":1,"highlight_end":1},{"text":"    ///         \"Palermo\",","highlight_start":1,"highlight_end":1},{"text":"    ///         \"Atlantis\",","highlight_start":1,"highlight_end":1},{"text":"    ///         Unit::Meters","highlight_start":1,"highlight_end":1},{"text":"    ///     );","highlight_start":1,"highlight_end":1},{"text":"    ///     // x is Ok(None)","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn geo_dist<K: ToRedisArgs, M1: ToRedisArgs, M2: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        member1: M1,","highlight_start":1,"highlight_end":1},{"text":"        member2: M2,","highlight_start":1,"highlight_end":1},{"text":"        unit: geo::Unit","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GEODIST\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(member1)","highlight_start":1,"highlight_end":1},{"text":"            .arg(member2)","highlight_start":1,"highlight_end":1},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return valid [Geohash][1] strings representing the position of one or","highlight_start":1,"highlight_end":1},{"text":"    /// more members of the geospatial index represented by the sorted set at","highlight_start":1,"highlight_end":1},{"text":"    /// key.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [1]: https://en.wikipedia.org/wiki/Geohash","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Example","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn get_hash(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":1},{"text":"    ///     let x: RedisResult<Vec<String>> = con.geo_hash(\"my_gis\", \"Palermo\");","highlight_start":1,"highlight_end":1},{"text":"    ///     // x is vec![\"sqc8b49rny0\"]","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    ///     let x: RedisResult<Vec<String>> = con.geo_hash(\"my_gis\", &[\"Palermo\", \"Catania\"]);","highlight_start":1,"highlight_end":1},{"text":"    ///     // x is vec![\"sqc8b49rny0\", \"sqdtr74hyu0\"]","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn geo_hash<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GEOHASH\").arg(key).arg(members)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the positions of all the specified members of the geospatial","highlight_start":1,"highlight_end":1},{"text":"    /// index represented by the sorted set at key.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Every position is a pair of `(longitude, latitude)`. [`redis::geo::Coord`][1]","highlight_start":1,"highlight_end":1},{"text":"    /// can be used to convert these value in a struct.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [1]: ./geo/struct.Coord.html","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Example","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::geo::Coord;","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn get_position(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":1},{"text":"    ///     let x: RedisResult<Vec<Vec<f64>>> = con.geo_pos(\"my_gis\", &[\"Palermo\", \"Catania\"]);","highlight_start":1,"highlight_end":1},{"text":"    ///     // x is [ [ 13.361389, 38.115556 ], [ 15.087269, 37.502669 ] ];","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    ///     let x: Vec<Coord<f64>> = con.geo_pos(\"my_gis\", \"Palermo\").unwrap();","highlight_start":1,"highlight_end":1},{"text":"    ///     // x[0].longitude is 13.361389","highlight_start":1,"highlight_end":1},{"text":"    ///     // x[0].latitude is 38.115556","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn geo_pos<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GEOPOS\").arg(key).arg(members)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the members of a sorted set populated with geospatial information","highlight_start":1,"highlight_end":1},{"text":"    /// using [`geo_add`](#method.geo_add), which are within the borders of the area","highlight_start":1,"highlight_end":1},{"text":"    /// specified with the center location and the maximum distance from the center","highlight_start":1,"highlight_end":1},{"text":"    /// (the radius).","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Every item in the result can be read with [`redis::geo::RadiusSearchResult`][1],","highlight_start":1,"highlight_end":1},{"text":"    /// which support the multiple formats returned by `GEORADIUS`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [1]: ./geo/struct.RadiusSearchResult.html","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::geo::{RadiusOptions, RadiusSearchResult, RadiusOrder, Unit};","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// fn radius(con: &mut redis::Connection) -> Vec<RadiusSearchResult> {","highlight_start":1,"highlight_end":1},{"text":"    ///     let opts = RadiusOptions::default().with_dist().order(RadiusOrder::Asc);","highlight_start":1,"highlight_end":1},{"text":"    ///     con.geo_radius(\"my_gis\", 15.90, 37.21, 51.39, Unit::Kilometers, opts).unwrap()","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn geo_radius<K: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        longitude: f64,","highlight_start":1,"highlight_end":1},{"text":"        latitude: f64,","highlight_start":1,"highlight_end":1},{"text":"        radius: f64,","highlight_start":1,"highlight_end":1},{"text":"        unit: geo::Unit,","highlight_start":1,"highlight_end":1},{"text":"        options: geo::RadiusOptions","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GEORADIUS\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(longitude)","highlight_start":1,"highlight_end":1},{"text":"            .arg(latitude)","highlight_start":1,"highlight_end":1},{"text":"            .arg(radius)","highlight_start":1,"highlight_end":1},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":1},{"text":"            .arg(options)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Retrieve members selected by distance with the center of `member`. The","highlight_start":1,"highlight_end":1},{"text":"    /// member itself is always contained in the results.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn geo_radius_by_member<K: ToRedisArgs, M: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        member: M,","highlight_start":1,"highlight_end":1},{"text":"        radius: f64,","highlight_start":1,"highlight_end":1},{"text":"        unit: geo::Unit,","highlight_start":1,"highlight_end":1},{"text":"        options: geo::RadiusOptions","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GEORADIUSBYMEMBER\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(member)","highlight_start":1,"highlight_end":1},{"text":"            .arg(radius)","highlight_start":1,"highlight_end":1},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":1},{"text":"            .arg(options)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":1},{"text":"    // streams commands","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Ack pending stream messages checked out by a consumer.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XACK <key> <group> <id> <id> ... <id>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xack<K: ToRedisArgs, G: ToRedisArgs, I: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        ids: &'a [I]) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XACK\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add a stream message by `key`. Use `*` as the `id` for the current timestamp.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XADD key <ID or *> [field value] [field value] ...","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xadd<K: ToRedisArgs, ID: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        id: ID,","highlight_start":1,"highlight_end":1},{"text":"        items: &'a [(F, V)]","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XADD\").arg(key).arg(id).arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// BTreeMap variant for adding a stream message by `key`.","highlight_start":1,"highlight_end":1},{"text":"    /// Use `*` as the `id` for the current timestamp.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XADD key <ID or *> [rust BTreeMap] ...","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xadd_map<K: ToRedisArgs, ID: ToRedisArgs, BTM: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        id: ID,","highlight_start":1,"highlight_end":1},{"text":"        map: BTM","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XADD\").arg(key).arg(id).arg(map)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add a stream message while capping the stream at a maxlength.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XADD key [MAXLEN [~|=] <count>] <ID or *> [field value] [field value] ...","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xadd_maxlen<","highlight_start":1,"highlight_end":1},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        ID: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        F: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        V: ToRedisArgs","highlight_start":1,"highlight_end":1},{"text":"    >(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        maxlen: streams::StreamMaxlen,","highlight_start":1,"highlight_end":1},{"text":"        id: ID,","highlight_start":1,"highlight_end":1},{"text":"        items: &'a [(F, V)]","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XADD\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(maxlen)","highlight_start":1,"highlight_end":1},{"text":"            .arg(id)","highlight_start":1,"highlight_end":1},{"text":"            .arg(items)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// BTreeMap variant for adding a stream message while capping the stream at a maxlength.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XADD key [MAXLEN [~|=] <count>] <ID or *> [rust BTreeMap] ...","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xadd_maxlen_map<K: ToRedisArgs, ID: ToRedisArgs, BTM: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        maxlen: streams::StreamMaxlen,","highlight_start":1,"highlight_end":1},{"text":"        id: ID,","highlight_start":1,"highlight_end":1},{"text":"        map: BTM","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XADD\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(maxlen)","highlight_start":1,"highlight_end":1},{"text":"            .arg(id)","highlight_start":1,"highlight_end":1},{"text":"            .arg(map)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Claim pending, unacked messages, after some period of time,","highlight_start":1,"highlight_end":1},{"text":"    /// currently checked out by another consumer.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// This method only accepts the must-have arguments for claiming messages.","highlight_start":1,"highlight_end":1},{"text":"    /// If optional arguments are required, see `xclaim_options` below.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XCLAIM <key> <group> <consumer> <min-idle-time> [<ID-1> <ID-2>]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xclaim<K: ToRedisArgs, G: ToRedisArgs, C: ToRedisArgs, MIT: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        consumer: C,","highlight_start":1,"highlight_end":1},{"text":"        min_idle_time: MIT,","highlight_start":1,"highlight_end":1},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XCLAIM\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":1},{"text":"            .arg(min_idle_time)","highlight_start":1,"highlight_end":1},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the optional arguments version for claiming unacked, pending messages","highlight_start":1,"highlight_end":1},{"text":"    /// currently checked out by another consumer.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Connection,Commands,RedisResult};","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::streams::{StreamClaimOptions,StreamClaimReply};","highlight_start":1,"highlight_end":1},{"text":"    /// let client = redis::Client::open(\"redis://127.0.0.1/0\").unwrap();","highlight_start":1,"highlight_end":1},{"text":"    /// let mut con = client.get_connection().unwrap();","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Claim all pending messages for key \"k1\",","highlight_start":1,"highlight_end":1},{"text":"    /// // from group \"g1\", checked out by consumer \"c1\"","highlight_start":1,"highlight_end":1},{"text":"    /// // for 10ms with RETRYCOUNT 2 and FORCE","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// let opts = StreamClaimOptions::default()","highlight_start":1,"highlight_end":1},{"text":"    ///     .with_force()","highlight_start":1,"highlight_end":1},{"text":"    ///     .retry(2);","highlight_start":1,"highlight_end":1},{"text":"    /// let results: RedisResult<StreamClaimReply> =","highlight_start":1,"highlight_end":1},{"text":"    ///     con.xclaim_options(\"k1\", \"g1\", \"c1\", 10, &[\"0\"], opts);","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // All optional arguments return a `Result<StreamClaimReply>` with one exception:","highlight_start":1,"highlight_end":1},{"text":"    /// // Passing JUSTID returns only the message `id` and omits the HashMap for each message.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// let opts = StreamClaimOptions::default()","highlight_start":1,"highlight_end":1},{"text":"    ///     .with_justid();","highlight_start":1,"highlight_end":1},{"text":"    /// let results: RedisResult<Vec<String>> =","highlight_start":1,"highlight_end":1},{"text":"    ///     con.xclaim_options(\"k1\", \"g1\", \"c1\", 10, &[\"0\"], opts);","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2>","highlight_start":1,"highlight_end":1},{"text":"    ///     [IDLE <milliseconds>] [TIME <mstime>] [RETRYCOUNT <count>]","highlight_start":1,"highlight_end":1},{"text":"    ///     [FORCE] [JUSTID]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xclaim_options<","highlight_start":1,"highlight_end":1},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        C: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        MIT: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        ID: ToRedisArgs","highlight_start":1,"highlight_end":1},{"text":"    >(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        consumer: C,","highlight_start":1,"highlight_end":1},{"text":"        min_idle_time: MIT,","highlight_start":1,"highlight_end":1},{"text":"        ids: &'a [ID],","highlight_start":1,"highlight_end":1},{"text":"        options: streams::StreamClaimOptions","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XCLAIM\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":1},{"text":"            .arg(min_idle_time)","highlight_start":1,"highlight_end":1},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":1},{"text":"            .arg(options)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Deletes a list of `id`s for a given stream `key`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XDEL <key> [<ID1> <ID2> ... <IDN>]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xdel<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XDEL\").arg(key).arg(ids)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This command is used for creating a consumer `group`. It expects the stream key","highlight_start":1,"highlight_end":1},{"text":"    /// to already exist. Otherwise, use `xgroup_create_mkstream` if it doesn't.","highlight_start":1,"highlight_end":1},{"text":"    /// The `id` is the starting message id all consumers should read from. Use `$` If you want","highlight_start":1,"highlight_end":1},{"text":"    /// all consumers to read from the last message added to stream.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XGROUP CREATE <key> <groupname> <id or $>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xgroup_create<K: ToRedisArgs, G: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        id: ID","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"CREATE\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(id)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the alternate version for creating a consumer `group`","highlight_start":1,"highlight_end":1},{"text":"    /// which makes the stream if it doesn't exist.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XGROUP CREATE <key> <groupname> <id or $> [MKSTREAM]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xgroup_create_mkstream<","highlight_start":1,"highlight_end":1},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        ID: ToRedisArgs","highlight_start":1,"highlight_end":1},{"text":"    >(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        id: ID","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"CREATE\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(id)","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"MKSTREAM\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Alter which `id` you want consumers to begin reading from an existing","highlight_start":1,"highlight_end":1},{"text":"    /// consumer `group`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XGROUP SETID <key> <groupname> <id or $>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xgroup_setid<K: ToRedisArgs, G: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        id: ID","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"SETID\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(id)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Destroy an existing consumer `group` for a given stream `key`","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XGROUP SETID <key> <groupname> <id or $>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xgroup_destroy<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XGROUP\").arg(\"DESTROY\").arg(key).arg(group)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This deletes a `consumer` from an existing consumer `group`","highlight_start":1,"highlight_end":1},{"text":"    /// for given stream `key.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XGROUP DELCONSUMER <key> <groupname> <consumername>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xgroup_delconsumer<K: ToRedisArgs, G: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        consumer: C","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"DELCONSUMER\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This returns all info details about","highlight_start":1,"highlight_end":1},{"text":"    /// which consumers have read messages for given consumer `group`.","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamInfoConsumersReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":1},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XINFO CONSUMERS <key> <group>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xinfo_consumers<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XINFO\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"CONSUMERS\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns all consumer `group`s created for a given stream `key`.","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamInfoGroupsReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":1},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XINFO GROUPS <key>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xinfo_groups<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XINFO\").arg(\"GROUPS\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns info about high-level stream details","highlight_start":1,"highlight_end":1},{"text":"    /// (first & last message `id`, length, number of groups, etc.)","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamInfoStreamReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":1},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XINFO STREAM <key>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xinfo_stream<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XINFO\").arg(\"STREAM\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the number of messages for a given stream `key`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XLEN <key>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XLEN\").arg(key)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is a basic version of making XPENDING command calls which only","highlight_start":1,"highlight_end":1},{"text":"    /// passes a stream `key` and consumer `group` and it","highlight_start":1,"highlight_end":1},{"text":"    /// returns details about which consumers have pending messages","highlight_start":1,"highlight_end":1},{"text":"    /// that haven't been acked.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// You can use this method along with","highlight_start":1,"highlight_end":1},{"text":"    /// `xclaim` or `xclaim_options` for determining which messages","highlight_start":1,"highlight_end":1},{"text":"    /// need to be retried.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamPendingReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XPENDING <key> <group> [<start> <stop> <count> [<consumer>]]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xpending<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G","highlight_start":1,"highlight_end":1},{"text":"    )  {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XPENDING\").arg(key).arg(group)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This XPENDING version returns a list of all messages over the range.","highlight_start":1,"highlight_end":1},{"text":"    /// You can use this for paginating pending messages (but without the message HashMap).","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Start and end follow the same rules `xrange` args. Set start to `-`","highlight_start":1,"highlight_end":1},{"text":"    /// and end to `+` for the entire stream.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamPendingCountReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XPENDING <key> <group> <start> <stop> <count>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xpending_count<","highlight_start":1,"highlight_end":1},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        S: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        E: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        C: ToRedisArgs","highlight_start":1,"highlight_end":1},{"text":"    >(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        start: S,","highlight_start":1,"highlight_end":1},{"text":"        end: E,","highlight_start":1,"highlight_end":1},{"text":"        count: C","highlight_start":1,"highlight_end":1},{"text":"    )  {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XPENDING\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(start)","highlight_start":1,"highlight_end":1},{"text":"            .arg(end)","highlight_start":1,"highlight_end":1},{"text":"            .arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// An alternate version of `xpending_count` which filters by `consumer` name.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Start and end follow the same rules `xrange` args. Set start to `-`","highlight_start":1,"highlight_end":1},{"text":"    /// and end to `+` for the entire stream.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamPendingCountReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XPENDING <key> <group> <start> <stop> <count> <consumer>","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xpending_consumer_count<","highlight_start":1,"highlight_end":1},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        S: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        E: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        C: ToRedisArgs,","highlight_start":1,"highlight_end":1},{"text":"        CN: ToRedisArgs","highlight_start":1,"highlight_end":1},{"text":"    >(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        group: G,","highlight_start":1,"highlight_end":1},{"text":"        start: S,","highlight_start":1,"highlight_end":1},{"text":"        end: E,","highlight_start":1,"highlight_end":1},{"text":"        count: C,","highlight_start":1,"highlight_end":1},{"text":"        consumer: CN","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XPENDING\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(group)","highlight_start":1,"highlight_end":1},{"text":"            .arg(start)","highlight_start":1,"highlight_end":1},{"text":"            .arg(end)","highlight_start":1,"highlight_end":1},{"text":"            .arg(count)","highlight_start":1,"highlight_end":1},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns a range of messages in a given stream `key`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Set `start` to `-` to begin at the first message.","highlight_start":1,"highlight_end":1},{"text":"    /// Set `end` to `+` to end the most recent message.","highlight_start":1,"highlight_end":1},{"text":"    /// You can pass message `id` to both `start` and `end`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Take note of the StreamRangeReply return type.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XRANGE key start end","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xrange<K: ToRedisArgs, S: ToRedisArgs, E: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        start: S,","highlight_start":1,"highlight_end":1},{"text":"        end: E","highlight_start":1,"highlight_end":1},{"text":"    )  {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XRANGE\").arg(key).arg(start).arg(end)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// A helper method for automatically returning all messages in a stream by `key`.","highlight_start":1,"highlight_end":1},{"text":"    /// **Use with caution!**","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XRANGE key - +","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xrange_all<K: ToRedisArgs>(key: K)  {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XRANGE\").arg(key).arg(\"-\").arg(\"+\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// A method for paginating a stream by `key`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XRANGE key start end [COUNT <n>]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xrange_count<K: ToRedisArgs, S: ToRedisArgs, E: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        start: S,","highlight_start":1,"highlight_end":1},{"text":"        end: E,","highlight_start":1,"highlight_end":1},{"text":"        count: C","highlight_start":1,"highlight_end":1},{"text":"    )  {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XRANGE\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(start)","highlight_start":1,"highlight_end":1},{"text":"            .arg(end)","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"COUNT\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Read a list of `id`s for each stream `key`.","highlight_start":1,"highlight_end":1},{"text":"    /// This is the basic form of reading streams.","highlight_start":1,"highlight_end":1},{"text":"    /// For more advanced control, like blocking, limiting, or reading by consumer `group`,","highlight_start":1,"highlight_end":1},{"text":"    /// see `xread_options`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XREAD STREAMS key_1 key_2 ... key_N ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xread<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        keys: &'a [K],","highlight_start":1,"highlight_end":1},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XREAD\").arg(\"STREAMS\").arg(keys).arg(ids)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This method handles setting optional arguments for","highlight_start":1,"highlight_end":1},{"text":"    /// `XREAD` or `XREADGROUP` Redis commands.","highlight_start":1,"highlight_end":1},{"text":"    /// ```no_run","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::{Connection,RedisResult,Commands};","highlight_start":1,"highlight_end":1},{"text":"    /// use redis::streams::{StreamReadOptions,StreamReadReply};","highlight_start":1,"highlight_end":1},{"text":"    /// let client = redis::Client::open(\"redis://127.0.0.1/0\").unwrap();","highlight_start":1,"highlight_end":1},{"text":"    /// let mut con = client.get_connection().unwrap();","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Read 10 messages from the start of the stream,","highlight_start":1,"highlight_end":1},{"text":"    /// // without registering as a consumer group.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// let opts = StreamReadOptions::default()","highlight_start":1,"highlight_end":1},{"text":"    ///     .count(10);","highlight_start":1,"highlight_end":1},{"text":"    /// let results: RedisResult<StreamReadReply> =","highlight_start":1,"highlight_end":1},{"text":"    ///     con.xread_options(&[\"k1\"], &[\"0\"], &opts);","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Read all undelivered messages for a given","highlight_start":1,"highlight_end":1},{"text":"    /// // consumer group. Be advised: the consumer group must already","highlight_start":1,"highlight_end":1},{"text":"    /// // exist before making this call. Also note: we're passing","highlight_start":1,"highlight_end":1},{"text":"    /// // '>' as the id here, which means all undelivered messages.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// let opts = StreamReadOptions::default()","highlight_start":1,"highlight_end":1},{"text":"    ///     .group(\"group-1\", \"consumer-1\");","highlight_start":1,"highlight_end":1},{"text":"    /// let results: RedisResult<StreamReadReply> =","highlight_start":1,"highlight_end":1},{"text":"    ///     con.xread_options(&[\"k1\"], &[\">\"], &opts);","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XREAD [BLOCK <milliseconds>] [COUNT <count>]","highlight_start":1,"highlight_end":1},{"text":"    ///     STREAMS key_1 key_2 ... key_N","highlight_start":1,"highlight_end":1},{"text":"    ///     ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// XREADGROUP [BLOCK <milliseconds>] [COUNT <count>] [NOACK] [GROUP group-name consumer-name]","highlight_start":1,"highlight_end":1},{"text":"    ///     STREAMS key_1 key_2 ... key_N","highlight_start":1,"highlight_end":1},{"text":"    ///     ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xread_options<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        keys: &'a [K],","highlight_start":1,"highlight_end":1},{"text":"        ids: &'a [ID],","highlight_start":1,"highlight_end":1},{"text":"        options: &'a streams::StreamReadOptions","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(if options.read_only() {","highlight_start":1,"highlight_end":1},{"text":"            \"XREAD\"","highlight_start":1,"highlight_end":1},{"text":"        } else {","highlight_start":1,"highlight_end":1},{"text":"            \"XREADGROUP\"","highlight_start":1,"highlight_end":1},{"text":"        })","highlight_start":1,"highlight_end":1},{"text":"        .arg(options)","highlight_start":1,"highlight_end":1},{"text":"        .arg(\"STREAMS\")","highlight_start":1,"highlight_end":1},{"text":"        .arg(keys)","highlight_start":1,"highlight_end":1},{"text":"        .arg(ids)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange`.","highlight_start":1,"highlight_end":1},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XREVRANGE key end start","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xrevrange<K: ToRedisArgs, E: ToRedisArgs, S: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        end: E,","highlight_start":1,"highlight_end":1},{"text":"        start: S","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XREVRANGE\").arg(key).arg(end).arg(start)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange_all`.","highlight_start":1,"highlight_end":1},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XREVRANGE key + -","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    fn xrevrange_all<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XREVRANGE\").arg(key).arg(\"+\").arg(\"-\")","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange_count`.","highlight_start":1,"highlight_end":1},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XREVRANGE key end start [COUNT <n>]","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xrevrange_count<K: ToRedisArgs, E: ToRedisArgs, S: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        end: E,","highlight_start":1,"highlight_end":1},{"text":"        start: S,","highlight_start":1,"highlight_end":1},{"text":"        count: C","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XREVRANGE\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(key)","highlight_start":1,"highlight_end":1},{"text":"            .arg(end)","highlight_start":1,"highlight_end":1},{"text":"            .arg(start)","highlight_start":1,"highlight_end":1},{"text":"            .arg(\"COUNT\")","highlight_start":1,"highlight_end":1},{"text":"            .arg(count)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Trim a stream `key` to a MAXLEN count.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// XTRIM <key> MAXLEN [~|=] <count>  (Same as XADD MAXLEN option)","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":1},{"text":"    fn xtrim<K: ToRedisArgs>(","highlight_start":1,"highlight_end":1},{"text":"        key: K,","highlight_start":1,"highlight_end":1},{"text":"        maxlen: streams::StreamMaxlen","highlight_start":1,"highlight_end":1},{"text":"    ) {","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"XTRIM\").arg(key).arg(maxlen)","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"implement_commands!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/macros.rs","byte_start":0,"byte_end":31,"line_start":1,"line_end":1,"column_start":1,"column_end":32,"is_primary":false,"text":[{"text":"macro_rules! implement_commands {","highlight_start":1,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `ping` found for struct `MultiplexedConnection` in the current scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:30:30\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let _: String = conn.ping().await?;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `xpending` with a similar name, but with different arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/mod.rs:41:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimplement_commands! {\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    'a\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1847\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `implement_commands` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `!: FromRedisValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/auth.rs","byte_start":1317,"byte_end":1323,"line_start":49,"line_end":49,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"        conn.set_ex(&session_id, session_json, SESSION_TTL).await?;","highlight_start":14,"highlight_end":20}],"label":"the trait `FromRedisValue` is not implemented for `!`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `FromRedisValue`:\n  ()\n  (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T10, T11, T12)\n  (T11, T12)\n  (T12,)\n  (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T4, T5, T6, T7, T8, T9, T10, T11, T12)\nand 42 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"did you intend to use the type `()` here instead?","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `redis::AsyncCommands::set_ex`","code":null,"level":"note","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/mod.rs","byte_start":3434,"byte_end":3440,"line_start":83,"line_end":83,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn set_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, seconds: usize) {","highlight_start":8,"highlight_end":14}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/macros.rs","byte_start":7006,"byte_end":7020,"line_start":167,"line_end":167,"column_start":25,"column_end":39,"is_primary":true,"text":[{"text":"                    RV: FromRedisValue,","highlight_start":25,"highlight_end":39}],"label":"required by this bound in `AsyncCommands::set_ex`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/mod.rs","byte_start":2151,"byte_end":64581,"line_start":41,"line_end":1847,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"implement_commands! {","highlight_start":1,"highlight_end":22},{"text":"    'a","highlight_start":1,"highlight_end":7},{"text":"    // most common operations","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key.  If key is a vec this becomes an `MGET`.","highlight_start":1,"highlight_end":73},{"text":"    fn get<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":37},{"text":"        cmd(if key.is_single_arg() { \"GET\" } else { \"MGET\" }).arg(key)","highlight_start":1,"highlight_end":71},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get values of keys","highlight_start":1,"highlight_end":27},{"text":"    fn mget<K: ToRedisArgs>(key: K){","highlight_start":1,"highlight_end":37},{"text":"        cmd(\"MGET\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all keys matching pattern","highlight_start":1,"highlight_end":39},{"text":"    fn keys<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"KEYS\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key.","highlight_start":1,"highlight_end":39},{"text":"    fn set<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":63},{"text":"        cmd(\"SET\").arg(key).arg(value)","highlight_start":1,"highlight_end":39},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key with options.","highlight_start":1,"highlight_end":52},{"text":"    fn set_options<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, options: SetOptions) {","highlight_start":1,"highlight_end":92},{"text":"        cmd(\"SET\").arg(key).arg(value).arg(options)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values.","highlight_start":1,"highlight_end":44},{"text":"    #[allow(deprecated)]","highlight_start":1,"highlight_end":25},{"text":"    #[deprecated(since = \"0.22.4\", note = \"Renamed to mset() to reflect Redis name\")]","highlight_start":1,"highlight_end":86},{"text":"    fn set_multiple<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":75},{"text":"        cmd(\"MSET\").arg(items)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values.","highlight_start":1,"highlight_end":44},{"text":"    fn mset<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"MSET\").arg(items)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value and expiration of a key.","highlight_start":1,"highlight_end":47},{"text":"    fn set_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, seconds: usize) {","highlight_start":1,"highlight_end":82},{"text":"        cmd(\"SETEX\").arg(key).arg(seconds).arg(value)","highlight_start":1,"highlight_end":54},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value and expiration in milliseconds of a key.","highlight_start":1,"highlight_end":63},{"text":"    fn pset_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, milliseconds: usize) {","highlight_start":1,"highlight_end":88},{"text":"        cmd(\"PSETEX\").arg(key).arg(milliseconds).arg(value)","highlight_start":1,"highlight_end":60},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value of a key, only if the key does not exist","highlight_start":1,"highlight_end":63},{"text":"    fn set_nx<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"SETNX\").arg(key).arg(value)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values failing if at least one already exists.","highlight_start":1,"highlight_end":83},{"text":"    fn mset_nx<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"MSETNX\").arg(items)","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key and return its old value.","highlight_start":1,"highlight_end":64},{"text":"    fn getset<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"GETSET\").arg(key).arg(value)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get a range of bytes/substring from the value of a key. Negative values provide an offset from the end of the value.","highlight_start":1,"highlight_end":125},{"text":"    fn getrange<K: ToRedisArgs>(key: K, from: isize, to: isize) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"GETRANGE\").arg(key).arg(from).arg(to)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Overwrite the part of the value stored in key at the specified offset.","highlight_start":1,"highlight_end":79},{"text":"    fn setrange<K: ToRedisArgs, V: ToRedisArgs>(key: K, offset: isize, value: V) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"SETRANGE\").arg(key).arg(offset).arg(value)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Delete one or more keys.","highlight_start":1,"highlight_end":33},{"text":"    fn del<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":37},{"text":"        cmd(\"DEL\").arg(key)","highlight_start":1,"highlight_end":28},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine if a key exists.","highlight_start":1,"highlight_end":35},{"text":"    fn exists<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":40},{"text":"        cmd(\"EXISTS\").arg(key)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the type of a key.","highlight_start":1,"highlight_end":37},{"text":"    fn key_type<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"TYPE\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set a key's time to live in seconds.","highlight_start":1,"highlight_end":45},{"text":"    fn expire<K: ToRedisArgs>(key: K, seconds: usize) {","highlight_start":1,"highlight_end":56},{"text":"        cmd(\"EXPIRE\").arg(key).arg(seconds)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the expiration for a key as a UNIX timestamp.","highlight_start":1,"highlight_end":58},{"text":"    fn expire_at<K: ToRedisArgs>(key: K, ts: usize) {","highlight_start":1,"highlight_end":54},{"text":"        cmd(\"EXPIREAT\").arg(key).arg(ts)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set a key's time to live in milliseconds.","highlight_start":1,"highlight_end":50},{"text":"    fn pexpire<K: ToRedisArgs>(key: K, ms: usize) {","highlight_start":1,"highlight_end":52},{"text":"        cmd(\"PEXPIRE\").arg(key).arg(ms)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the expiration for a key as a UNIX timestamp in milliseconds.","highlight_start":1,"highlight_end":74},{"text":"    fn pexpire_at<K: ToRedisArgs>(key: K, ts: usize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"PEXPIREAT\").arg(key).arg(ts)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove the expiration from a key.","highlight_start":1,"highlight_end":42},{"text":"    fn persist<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"PERSIST\").arg(key)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the expiration time of a key.","highlight_start":1,"highlight_end":42},{"text":"    fn ttl<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":37},{"text":"        cmd(\"TTL\").arg(key)","highlight_start":1,"highlight_end":28},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the expiration time of a key in milliseconds.","highlight_start":1,"highlight_end":58},{"text":"    fn pttl<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"PTTL\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key and set expiration","highlight_start":1,"highlight_end":50},{"text":"    fn get_ex<K: ToRedisArgs>(key: K, expire_at: Expiry) {","highlight_start":1,"highlight_end":59},{"text":"        let (option, time_arg) = match expire_at {","highlight_start":1,"highlight_end":51},{"text":"            Expiry::EX(sec) => (\"EX\", Some(sec)),","highlight_start":1,"highlight_end":50},{"text":"            Expiry::PX(ms) => (\"PX\", Some(ms)),","highlight_start":1,"highlight_end":48},{"text":"            Expiry::EXAT(timestamp_sec) => (\"EXAT\", Some(timestamp_sec)),","highlight_start":1,"highlight_end":74},{"text":"            Expiry::PXAT(timestamp_ms) => (\"PXAT\", Some(timestamp_ms)),","highlight_start":1,"highlight_end":72},{"text":"            Expiry::PERSIST => (\"PERSIST\", None),","highlight_start":1,"highlight_end":50},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GETEX\").arg(key).arg(option).arg(time_arg)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key and delete it","highlight_start":1,"highlight_end":45},{"text":"    fn get_del<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"GETDEL\").arg(key)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Rename a key.","highlight_start":1,"highlight_end":22},{"text":"    fn rename<K: ToRedisArgs, N: ToRedisArgs>(key: K, new_key: N) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"RENAME\").arg(key).arg(new_key)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Rename a key, only if the new key does not exist.","highlight_start":1,"highlight_end":58},{"text":"    fn rename_nx<K: ToRedisArgs, N: ToRedisArgs>(key: K, new_key: N) {","highlight_start":1,"highlight_end":71},{"text":"        cmd(\"RENAMENX\").arg(key).arg(new_key)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unlink one or more keys.","highlight_start":1,"highlight_end":33},{"text":"    fn unlink<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":40},{"text":"        cmd(\"UNLINK\").arg(key)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // common string operations","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Append a value to a key.","highlight_start":1,"highlight_end":33},{"text":"    fn append<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"APPEND\").arg(key).arg(value)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increment the numeric value of a key by the given amount.  This","highlight_start":1,"highlight_end":72},{"text":"    /// issues a `INCRBY` or `INCRBYFLOAT` depending on the type.","highlight_start":1,"highlight_end":66},{"text":"    fn incr<K: ToRedisArgs, V: ToRedisArgs>(key: K, delta: V) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(if delta.describe_numeric_behavior() == NumericBehavior::NumberIsFloat {","highlight_start":1,"highlight_end":85},{"text":"            \"INCRBYFLOAT\"","highlight_start":1,"highlight_end":26},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            \"INCRBY\"","highlight_start":1,"highlight_end":21},{"text":"        }).arg(key).arg(delta)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Decrement the numeric value of a key by the given amount.","highlight_start":1,"highlight_end":66},{"text":"    fn decr<K: ToRedisArgs, V: ToRedisArgs>(key: K, delta: V) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(\"DECRBY\").arg(key).arg(delta)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets or clears the bit at offset in the string value stored at key.","highlight_start":1,"highlight_end":76},{"text":"    fn setbit<K: ToRedisArgs>(key: K, offset: usize, value: bool) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"SETBIT\").arg(key).arg(offset).arg(i32::from(value))","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the bit value at offset in the string value stored at key.","highlight_start":1,"highlight_end":75},{"text":"    fn getbit<K: ToRedisArgs>(key: K, offset: usize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"GETBIT\").arg(key).arg(offset)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count set bits in a string.","highlight_start":1,"highlight_end":36},{"text":"    fn bitcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"BITCOUNT\").arg(key)","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count set bits in a string in a range.","highlight_start":1,"highlight_end":47},{"text":"    fn bitcount_range<K: ToRedisArgs>(key: K, start: usize, end: usize) {","highlight_start":1,"highlight_end":74},{"text":"        cmd(\"BITCOUNT\").arg(key).arg(start).arg(end)","highlight_start":1,"highlight_end":53},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise AND between multiple keys (containing string values)","highlight_start":1,"highlight_end":79},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":53},{"text":"    fn bit_and<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"BITOP\").arg(\"AND\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise OR between multiple keys (containing string values)","highlight_start":1,"highlight_end":78},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":53},{"text":"    fn bit_or<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":71},{"text":"        cmd(\"BITOP\").arg(\"OR\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise XOR between multiple keys (containing string values)","highlight_start":1,"highlight_end":79},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":53},{"text":"    fn bit_xor<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"BITOP\").arg(\"XOR\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise NOT of the key (containing string values)","highlight_start":1,"highlight_end":68},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":53},{"text":"    fn bit_not<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckey: S) {","highlight_start":1,"highlight_end":71},{"text":"        cmd(\"BITOP\").arg(\"NOT\").arg(dstkey).arg(srckey)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the length of the value stored in a key.","highlight_start":1,"highlight_end":53},{"text":"    fn strlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":40},{"text":"        cmd(\"STRLEN\").arg(key)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // hash operations","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets a single (or multiple) fields from a hash.","highlight_start":1,"highlight_end":56},{"text":"    fn hget<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(if field.is_single_arg() { \"HGET\" } else { \"HMGET\" }).arg(key).arg(field)","highlight_start":1,"highlight_end":86},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Deletes a single (or multiple) fields from a hash.","highlight_start":1,"highlight_end":59},{"text":"    fn hdel<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(\"HDEL\").arg(key).arg(field)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a single field in a hash.","highlight_start":1,"highlight_end":39},{"text":"    fn hset<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, field: F, value: V) {","highlight_start":1,"highlight_end":90},{"text":"        cmd(\"HSET\").arg(key).arg(field).arg(value)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a single field in a hash if it does not exist.","highlight_start":1,"highlight_end":60},{"text":"    fn hset_nx<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, field: F, value: V) {","highlight_start":1,"highlight_end":93},{"text":"        cmd(\"HSETNX\").arg(key).arg(field).arg(value)","highlight_start":1,"highlight_end":53},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a multiple fields in a hash.","highlight_start":1,"highlight_end":42},{"text":"    fn hset_multiple<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, items: &'a [(F, V)]) {","highlight_start":1,"highlight_end":100},{"text":"        cmd(\"HMSET\").arg(key).arg(items)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increments a value.","highlight_start":1,"highlight_end":28},{"text":"    fn hincr<K: ToRedisArgs, F: ToRedisArgs, D: ToRedisArgs>(key: K, field: F, delta: D) {","highlight_start":1,"highlight_end":91},{"text":"        cmd(if delta.describe_numeric_behavior() == NumericBehavior::NumberIsFloat {","highlight_start":1,"highlight_end":85},{"text":"            \"HINCRBYFLOAT\"","highlight_start":1,"highlight_end":27},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            \"HINCRBY\"","highlight_start":1,"highlight_end":22},{"text":"        }).arg(key).arg(field).arg(delta)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Checks if a field in a hash exists.","highlight_start":1,"highlight_end":44},{"text":"    fn hexists<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"HEXISTS\").arg(key).arg(field)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the keys in a hash.","highlight_start":1,"highlight_end":37},{"text":"    fn hkeys<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":39},{"text":"        cmd(\"HKEYS\").arg(key)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the values in a hash.","highlight_start":1,"highlight_end":39},{"text":"    fn hvals<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":39},{"text":"        cmd(\"HVALS\").arg(key)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the fields and values in a hash.","highlight_start":1,"highlight_end":50},{"text":"    fn hgetall<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"HGETALL\").arg(key)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets the length of a hash.","highlight_start":1,"highlight_end":35},{"text":"    fn hlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"HLEN\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // list operations","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop an element from a list, push it to another list","highlight_start":1,"highlight_end":60},{"text":"    /// and return it; or block until one is available","highlight_start":1,"highlight_end":55},{"text":"    fn blmove<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, src_dir: Direction, dst_dir: Direction, timeout: usize) {","highlight_start":1,"highlight_end":126},{"text":"        cmd(\"BLMOVE\").arg(srckey).arg(dstkey).arg(src_dir).arg(dst_dir).arg(timeout)","highlight_start":1,"highlight_end":85},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pops `count` elements from the first non-empty list key from the list of","highlight_start":1,"highlight_end":81},{"text":"    /// provided key names; or blocks until one is available.","highlight_start":1,"highlight_end":62},{"text":"    fn blmpop<K: ToRedisArgs>(timeout: usize, numkeys: usize, key: K, dir: Direction, count: usize){","highlight_start":1,"highlight_end":101},{"text":"        cmd(\"BLMPOP\").arg(timeout).arg(numkeys).arg(key).arg(dir).arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":90},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and get the first element in a list, or block until one is available.","highlight_start":1,"highlight_end":85},{"text":"    fn blpop<K: ToRedisArgs>(key: K, timeout: usize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"BLPOP\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and get the last element in a list, or block until one is available.","highlight_start":1,"highlight_end":84},{"text":"    fn brpop<K: ToRedisArgs>(key: K, timeout: usize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"BRPOP\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop a value from a list, push it to another list and return it;","highlight_start":1,"highlight_end":72},{"text":"    /// or block until one is available.","highlight_start":1,"highlight_end":41},{"text":"    fn brpoplpush<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, timeout: usize) {","highlight_start":1,"highlight_end":90},{"text":"        cmd(\"BRPOPLPUSH\").arg(srckey).arg(dstkey).arg(timeout)","highlight_start":1,"highlight_end":63},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get an element from a list by its index.","highlight_start":1,"highlight_end":49},{"text":"    fn lindex<K: ToRedisArgs>(key: K, index: isize) {","highlight_start":1,"highlight_end":54},{"text":"        cmd(\"LINDEX\").arg(key).arg(index)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert an element before another element in a list.","highlight_start":1,"highlight_end":60},{"text":"    fn linsert_before<K: ToRedisArgs, P: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":71},{"text":"            key: K, pivot: P, value: V) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"LINSERT\").arg(key).arg(\"BEFORE\").arg(pivot).arg(value)","highlight_start":1,"highlight_end":68},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert an element after another element in a list.","highlight_start":1,"highlight_end":59},{"text":"    fn linsert_after<K: ToRedisArgs, P: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":70},{"text":"            key: K, pivot: P, value: V) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"LINSERT\").arg(key).arg(\"AFTER\").arg(pivot).arg(value)","highlight_start":1,"highlight_end":67},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the length of the list stored at key.","highlight_start":1,"highlight_end":54},{"text":"    fn llen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"LLEN\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop an element a list, push it to another list and return it","highlight_start":1,"highlight_end":69},{"text":"    fn lmove<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, src_dir: Direction, dst_dir: Direction) {","highlight_start":1,"highlight_end":109},{"text":"        cmd(\"LMOVE\").arg(srckey).arg(dstkey).arg(src_dir).arg(dst_dir)","highlight_start":1,"highlight_end":71},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pops `count` elements from the first non-empty list key from the list of","highlight_start":1,"highlight_end":81},{"text":"    /// provided key names.","highlight_start":1,"highlight_end":28},{"text":"    fn lmpop<K: ToRedisArgs>( numkeys: usize, key: K, dir: Direction, count: usize) {","highlight_start":1,"highlight_end":86},{"text":"        cmd(\"LMPOP\").arg(numkeys).arg(key).arg(dir).arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":76},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the up to `count` first elements of the list stored at key.","highlight_start":1,"highlight_end":88},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If `count` is not specified, then defaults to first element.","highlight_start":1,"highlight_end":69},{"text":"    fn lpop<K: ToRedisArgs>(key: K, count: Option<core::num::NonZeroUsize>) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"LPOP\").arg(key).arg(count)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the index of the first matching value of the list stored at key.","highlight_start":1,"highlight_end":81},{"text":"    fn lpos<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, options: LposOptions) {","highlight_start":1,"highlight_end":86},{"text":"        cmd(\"LPOS\").arg(key).arg(value).arg(options)","highlight_start":1,"highlight_end":53},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert all the specified values at the head of the list stored at key.","highlight_start":1,"highlight_end":79},{"text":"    fn lpush<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":65},{"text":"        cmd(\"LPUSH\").arg(key).arg(value)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Inserts a value at the head of the list stored at key, only if key","highlight_start":1,"highlight_end":75},{"text":"    /// already exists and holds a list.","highlight_start":1,"highlight_end":41},{"text":"    fn lpush_exists<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"LPUSHX\").arg(key).arg(value)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the specified elements of the list stored at key.","highlight_start":1,"highlight_end":66},{"text":"    fn lrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"LRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes the first count occurrences of elements equal to value","highlight_start":1,"highlight_end":71},{"text":"    /// from the list stored at key.","highlight_start":1,"highlight_end":37},{"text":"    fn lrem<K: ToRedisArgs, V: ToRedisArgs>(key: K, count: isize, value: V) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"LREM\").arg(key).arg(count).arg(value)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Trim an existing list so that it will contain only the specified","highlight_start":1,"highlight_end":73},{"text":"    /// range of elements specified.","highlight_start":1,"highlight_end":37},{"text":"    fn ltrim<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"LTRIM\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets the list element at index to value","highlight_start":1,"highlight_end":48},{"text":"    fn lset<K: ToRedisArgs, V: ToRedisArgs>(key: K, index: isize, value: V) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"LSET\").arg(key).arg(index).arg(value)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the up to `count` last elements of the list stored at key","highlight_start":1,"highlight_end":86},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If `count` is not specified, then defaults to last element.","highlight_start":1,"highlight_end":68},{"text":"    fn rpop<K: ToRedisArgs>(key: K, count: Option<core::num::NonZeroUsize>) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"RPOP\").arg(key).arg(count)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop a value from a list, push it to another list and return it.","highlight_start":1,"highlight_end":72},{"text":"    fn rpoplpush<K: ToRedisArgs, D: ToRedisArgs>(key: K, dstkey: D) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"RPOPLPUSH\").arg(key).arg(dstkey)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert all the specified values at the tail of the list stored at key.","highlight_start":1,"highlight_end":79},{"text":"    fn rpush<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":65},{"text":"        cmd(\"RPUSH\").arg(key).arg(value)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Inserts value at the tail of the list stored at key, only if key","highlight_start":1,"highlight_end":73},{"text":"    /// already exists and holds a list.","highlight_start":1,"highlight_end":41},{"text":"    fn rpush_exists<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"RPUSHX\").arg(key).arg(value)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // set commands","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add one or more members to a set.","highlight_start":1,"highlight_end":42},{"text":"    fn sadd<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":65},{"text":"        cmd(\"SADD\").arg(key).arg(member)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the number of members in a set.","highlight_start":1,"highlight_end":44},{"text":"    fn scard<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":39},{"text":"        cmd(\"SCARD\").arg(key)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Subtract multiple sets.","highlight_start":1,"highlight_end":32},{"text":"    fn sdiff<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":40},{"text":"        cmd(\"SDIFF\").arg(keys)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Subtract multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":69},{"text":"    fn sdiffstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"SDIFFSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sets.","highlight_start":1,"highlight_end":33},{"text":"    fn sinter<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"SINTER\").arg(keys)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":70},{"text":"    fn sinterstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":73},{"text":"        cmd(\"SINTERSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine if a given value is a member of a set.","highlight_start":1,"highlight_end":57},{"text":"    fn sismember<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"SISMEMBER\").arg(key).arg(member)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get all the members in a set.","highlight_start":1,"highlight_end":38},{"text":"    fn smembers<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"SMEMBERS\").arg(key)","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Move a member from one set to another.","highlight_start":1,"highlight_end":47},{"text":"    fn smove<S: ToRedisArgs, D: ToRedisArgs, M: ToRedisArgs>(srckey: S, dstkey: D, member: M) {","highlight_start":1,"highlight_end":96},{"text":"        cmd(\"SMOVE\").arg(srckey).arg(dstkey).arg(member)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and return a random member from a set.","highlight_start":1,"highlight_end":54},{"text":"    fn spop<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"SPOP\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get one random member from a set.","highlight_start":1,"highlight_end":42},{"text":"    fn srandmember<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":45},{"text":"        cmd(\"SRANDMEMBER\").arg(key)","highlight_start":1,"highlight_end":36},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get multiple random members from a set.","highlight_start":1,"highlight_end":48},{"text":"    fn srandmember_multiple<K: ToRedisArgs>(key: K, count: usize) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"SRANDMEMBER\").arg(key).arg(count)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove one or more members from a set.","highlight_start":1,"highlight_end":47},{"text":"    fn srem<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":65},{"text":"        cmd(\"SREM\").arg(key).arg(member)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple sets.","highlight_start":1,"highlight_end":27},{"text":"    fn sunion<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"SUNION\").arg(keys)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":64},{"text":"    fn sunionstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":73},{"text":"        cmd(\"SUNIONSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // sorted set commands","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add one member to a sorted set, or update its score if it already exists.","highlight_start":1,"highlight_end":82},{"text":"    fn zadd<K: ToRedisArgs, S: ToRedisArgs, M: ToRedisArgs>(key: K, member: M, score: S) {","highlight_start":1,"highlight_end":91},{"text":"        cmd(\"ZADD\").arg(key).arg(score).arg(member)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple members to a sorted set, or update its score if it already exists.","highlight_start":1,"highlight_end":88},{"text":"    fn zadd_multiple<K: ToRedisArgs, S: ToRedisArgs, M: ToRedisArgs>(key: K, items: &'a [(S, M)]) {","highlight_start":1,"highlight_end":100},{"text":"        cmd(\"ZADD\").arg(key).arg(items)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the number of members in a sorted set.","highlight_start":1,"highlight_end":51},{"text":"    fn zcard<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":39},{"text":"        cmd(\"ZCARD\").arg(key)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count the members in a sorted set with scores within the given values.","highlight_start":1,"highlight_end":79},{"text":"    fn zcount<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":90},{"text":"        cmd(\"ZCOUNT\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increments the member in a sorted set at key by delta.","highlight_start":1,"highlight_end":63},{"text":"    /// If the member does not exist, it is added with delta as its score.","highlight_start":1,"highlight_end":75},{"text":"    fn zincr<K: ToRedisArgs, M: ToRedisArgs, D: ToRedisArgs>(key: K, member: M, delta: D) {","highlight_start":1,"highlight_end":92},{"text":"        cmd(\"ZINCRBY\").arg(key).arg(delta).arg(member)","highlight_start":1,"highlight_end":55},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":77},{"text":"    /// a new key using SUM as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zinterstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":79},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys)","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":77},{"text":"    /// a new key using MIN as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zinterstore_min<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\")","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":77},{"text":"    /// a new key using MAX as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zinterstore_max<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\")","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore`], but with the ability to specify a","highlight_start":1,"highlight_end":69},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zinterstore_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":108},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore_min`], but with the ability to specify a","highlight_start":1,"highlight_end":73},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zinterstore_min_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":112},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":121},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore_max`], but with the ability to specify a","highlight_start":1,"highlight_end":73},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zinterstore_max_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":112},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":121},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count the number of members in a sorted set between a given lexicographical range.","highlight_start":1,"highlight_end":91},{"text":"    fn zlexcount<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":93},{"text":"        cmd(\"ZLEXCOUNT\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the highest scores in a sorted set","highlight_start":1,"highlight_end":88},{"text":"    fn zpopmax<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"ZPOPMAX\").arg(key).arg(count)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the lowest scores in a sorted set","highlight_start":1,"highlight_end":87},{"text":"    fn zpopmin<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"ZPOPMIN\").arg(key).arg(count)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the highest scores,","highlight_start":1,"highlight_end":73},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":79},{"text":"    fn zmpop_max<K: ToRedisArgs>(keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(\"ZMPOP\").arg(keys.len()).arg(keys).arg(\"MAX\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":82},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the lowest scores,","highlight_start":1,"highlight_end":72},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":79},{"text":"    fn zmpop_min<K: ToRedisArgs>(keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(\"ZMPOP\").arg(keys.len()).arg(keys).arg(\"MIN\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":82},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return up to count random members in a sorted set (or 1 if `count == None`)","highlight_start":1,"highlight_end":84},{"text":"    fn zrandmember<K: ToRedisArgs>(key: K, count: Option<isize>) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"ZRANDMEMBER\").arg(key).arg(count)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return up to count random members in a sorted set with scores","highlight_start":1,"highlight_end":70},{"text":"    fn zrandmember_withscores<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"ZRANDMEMBER\").arg(key).arg(count).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index","highlight_start":1,"highlight_end":60},{"text":"    fn zrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"ZRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index with scores.","highlight_start":1,"highlight_end":73},{"text":"    fn zrange_withscores<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"ZRANGE\").arg(key).arg(start).arg(stop).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":70},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical range.","highlight_start":1,"highlight_end":77},{"text":"    fn zrangebylex<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":95},{"text":"        cmd(\"ZRANGEBYLEX\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":54},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical","highlight_start":1,"highlight_end":70},{"text":"    /// range with offset and limit.","highlight_start":1,"highlight_end":37},{"text":"    fn zrangebylex_limit<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(","highlight_start":1,"highlight_end":75},{"text":"            key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"ZRANGEBYLEX\").arg(key).arg(min).arg(max).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":90},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical range.","highlight_start":1,"highlight_end":77},{"text":"    fn zrevrangebylex<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":98},{"text":"        cmd(\"ZREVRANGEBYLEX\").arg(key).arg(max).arg(min)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical","highlight_start":1,"highlight_end":70},{"text":"    /// range with offset and limit.","highlight_start":1,"highlight_end":37},{"text":"    fn zrevrangebylex_limit<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(","highlight_start":1,"highlight_end":78},{"text":"            key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"ZREVRANGEBYLEX\").arg(key).arg(max).arg(min).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score.","highlight_start":1,"highlight_end":61},{"text":"    fn zrangebyscore<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":97},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with scores.","highlight_start":1,"highlight_end":73},{"text":"    fn zrangebyscore_withscores<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":108},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":74},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit.","highlight_start":1,"highlight_end":72},{"text":"    fn zrangebyscore_limit<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>","highlight_start":1,"highlight_end":76},{"text":"            (key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":92},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit with scores.","highlight_start":1,"highlight_end":84},{"text":"    fn zrangebyscore_limit_withscores<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>","highlight_start":1,"highlight_end":87},{"text":"            (key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":74},{"text":"            .arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the index of a member in a sorted set.","highlight_start":1,"highlight_end":57},{"text":"    fn zrank<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"ZRANK\").arg(key).arg(member)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove one or more members from a sorted set.","highlight_start":1,"highlight_end":54},{"text":"    fn zrem<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"ZREM\").arg(key).arg(members)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set between the given lexicographical range.","highlight_start":1,"highlight_end":84},{"text":"    fn zrembylex<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":93},{"text":"        cmd(\"ZREMRANGEBYLEX\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set within the given indexes.","highlight_start":1,"highlight_end":69},{"text":"    fn zremrangebyrank<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":76},{"text":"        cmd(\"ZREMRANGEBYRANK\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set within the given scores.","highlight_start":1,"highlight_end":68},{"text":"    fn zrembyscore<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":95},{"text":"        cmd(\"ZREMRANGEBYSCORE\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":59},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index, with scores","highlight_start":1,"highlight_end":73},{"text":"    /// ordered from high to low.","highlight_start":1,"highlight_end":34},{"text":"    fn zrevrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"ZREVRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":55},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index, with scores","highlight_start":1,"highlight_end":73},{"text":"    /// ordered from high to low.","highlight_start":1,"highlight_end":34},{"text":"    fn zrevrange_withscores<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":81},{"text":"        cmd(\"ZREVRANGE\").arg(key).arg(start).arg(stop).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":73},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score.","highlight_start":1,"highlight_end":61},{"text":"    fn zrevrangebyscore<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":100},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min)","highlight_start":1,"highlight_end":59},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with scores.","highlight_start":1,"highlight_end":73},{"text":"    fn zrevrangebyscore_withscores<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":111},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":77},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit.","highlight_start":1,"highlight_end":72},{"text":"    fn zrevrangebyscore_limit<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>","highlight_start":1,"highlight_end":79},{"text":"            (key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":95},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit with scores.","highlight_start":1,"highlight_end":84},{"text":"    fn zrevrangebyscore_limit_withscores<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>","highlight_start":1,"highlight_end":90},{"text":"            (key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":77},{"text":"            .arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the index of a member in a sorted set, with scores ordered from high to low.","highlight_start":1,"highlight_end":95},{"text":"    fn zrevrank<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZREVRANK\").arg(key).arg(member)","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the score associated with the given member in a sorted set.","highlight_start":1,"highlight_end":72},{"text":"    fn zscore<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"ZSCORE\").arg(key).arg(member)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the scores associated with multiple members in a sorted set.","highlight_start":1,"highlight_end":73},{"text":"    fn zscore_multiple<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: &'a [M]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZMSCORE\").arg(key).arg(members)","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":74},{"text":"    /// a new key using SUM as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zunionstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":79},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys)","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":74},{"text":"    /// a new key using MIN as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zunionstore_min<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\")","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":74},{"text":"    /// a new key using MAX as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zunionstore_max<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\")","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore`], but with the ability to specify a","highlight_start":1,"highlight_end":69},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zunionstore_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":108},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore_min`], but with the ability to specify a","highlight_start":1,"highlight_end":73},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zunionstore_min_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":112},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":121},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore_max`], but with the ability to specify a","highlight_start":1,"highlight_end":73},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zunionstore_max_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":112},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":121},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // hyperloglog commands","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Adds the specified elements to the specified HyperLogLog.","highlight_start":1,"highlight_end":66},{"text":"    fn pfadd<K: ToRedisArgs, E: ToRedisArgs>(key: K, element: E) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"PFADD\").arg(key).arg(element)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the approximated cardinality of the set(s) observed by the","highlight_start":1,"highlight_end":74},{"text":"    /// HyperLogLog at key(s).","highlight_start":1,"highlight_end":31},{"text":"    fn pfcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"PFCOUNT\").arg(key)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Merge N different HyperLogLogs into a single one.","highlight_start":1,"highlight_end":58},{"text":"    fn pfmerge<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"PFMERGE\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Posts a message to the given channel.","highlight_start":1,"highlight_end":46},{"text":"    fn publish<K: ToRedisArgs, E: ToRedisArgs>(channel: K, message: E) {","highlight_start":1,"highlight_end":73},{"text":"        cmd(\"PUBLISH\").arg(channel).arg(message)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Object commands","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the encoding of a key.","highlight_start":1,"highlight_end":39},{"text":"    fn object_encoding<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":49},{"text":"        cmd(\"OBJECT\").arg(\"ENCODING\").arg(key)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the time in seconds since the last access of a key.","highlight_start":1,"highlight_end":68},{"text":"    fn object_idletime<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":49},{"text":"        cmd(\"OBJECT\").arg(\"IDLETIME\").arg(key)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the logarithmic access frequency counter of a key.","highlight_start":1,"highlight_end":67},{"text":"    fn object_freq<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":45},{"text":"        cmd(\"OBJECT\").arg(\"FREQ\").arg(key)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the reference count of a key.","highlight_start":1,"highlight_end":46},{"text":"    fn object_refcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":49},{"text":"        cmd(\"OBJECT\").arg(\"REFCOUNT\").arg(key)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // ACL commands","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// When Redis is configured to use an ACL file (with the aclfile","highlight_start":1,"highlight_end":70},{"text":"    /// configuration option), this command will reload the ACLs from the file,","highlight_start":1,"highlight_end":80},{"text":"    /// replacing all the current ACL rules with the ones defined in the file.","highlight_start":1,"highlight_end":79},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_load<>() {","highlight_start":1,"highlight_end":22},{"text":"        cmd(\"ACL\").arg(\"LOAD\")","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// When Redis is configured to use an ACL file (with the aclfile","highlight_start":1,"highlight_end":70},{"text":"    /// configuration option), this command will save the currently defined","highlight_start":1,"highlight_end":76},{"text":"    /// ACLs from the server memory to the ACL file.","highlight_start":1,"highlight_end":53},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_save<>() {","highlight_start":1,"highlight_end":22},{"text":"        cmd(\"ACL\").arg(\"SAVE\")","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows the currently active ACL rules in the Redis server.","highlight_start":1,"highlight_end":66},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_list<>() {","highlight_start":1,"highlight_end":22},{"text":"        cmd(\"ACL\").arg(\"LIST\")","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows a list of all the usernames of the currently configured users in","highlight_start":1,"highlight_end":79},{"text":"    /// the Redis ACL system.","highlight_start":1,"highlight_end":30},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_users<>() {","highlight_start":1,"highlight_end":23},{"text":"        cmd(\"ACL\").arg(\"USERS\")","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns all the rules defined for an existing ACL user.","highlight_start":1,"highlight_end":64},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_getuser<K: ToRedisArgs>(username: K) {","highlight_start":1,"highlight_end":50},{"text":"        cmd(\"ACL\").arg(\"GETUSER\").arg(username)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an ACL user without any privilege.","highlight_start":1,"highlight_end":51},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_setuser<K: ToRedisArgs>(username: K) {","highlight_start":1,"highlight_end":50},{"text":"        cmd(\"ACL\").arg(\"SETUSER\").arg(username)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an ACL user with the specified rules or modify the rules of","highlight_start":1,"highlight_end":76},{"text":"    /// an existing user.","highlight_start":1,"highlight_end":26},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_setuser_rules<K: ToRedisArgs>(username: K, rules: &'a [acl::Rule]) {","highlight_start":1,"highlight_end":80},{"text":"        cmd(\"ACL\").arg(\"SETUSER\").arg(username).arg(rules)","highlight_start":1,"highlight_end":59},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Delete all the specified ACL users and terminate all the connections","highlight_start":1,"highlight_end":77},{"text":"    /// that are authenticated with such users.","highlight_start":1,"highlight_end":48},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_deluser<K: ToRedisArgs>(usernames: &'a [K]) {","highlight_start":1,"highlight_end":57},{"text":"        cmd(\"ACL\").arg(\"DELUSER\").arg(usernames)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows the available ACL categories.","highlight_start":1,"highlight_end":44},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_cat<>() {","highlight_start":1,"highlight_end":21},{"text":"        cmd(\"ACL\").arg(\"CAT\")","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows all the Redis commands in the specified category.","highlight_start":1,"highlight_end":64},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_cat_categoryname<K: ToRedisArgs>(categoryname: K) {","highlight_start":1,"highlight_end":63},{"text":"        cmd(\"ACL\").arg(\"CAT\").arg(categoryname)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Generates a 256-bits password starting from /dev/urandom if available.","highlight_start":1,"highlight_end":79},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_genpass<>() {","highlight_start":1,"highlight_end":25},{"text":"        cmd(\"ACL\").arg(\"GENPASS\")","highlight_start":1,"highlight_end":34},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Generates a 1-to-1024-bits password starting from /dev/urandom if available.","highlight_start":1,"highlight_end":85},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_genpass_bits<>(bits: isize) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"ACL\").arg(\"GENPASS\").arg(bits)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the username the current connection is authenticated with.","highlight_start":1,"highlight_end":75},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_whoami<>() {","highlight_start":1,"highlight_end":24},{"text":"        cmd(\"ACL\").arg(\"WHOAMI\")","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows a list of recent ACL security events","highlight_start":1,"highlight_end":51},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_log<>(count: isize) {","highlight_start":1,"highlight_end":33},{"text":"        cmd(\"ACL\").arg(\"LOG\").arg(count)","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Clears the ACL log.","highlight_start":1,"highlight_end":28},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_log_reset<>() {","highlight_start":1,"highlight_end":27},{"text":"        cmd(\"ACL\").arg(\"LOG\").arg(\"RESET\")","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns a helpful text describing the different subcommands.","highlight_start":1,"highlight_end":69},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_help<>() {","highlight_start":1,"highlight_end":22},{"text":"        cmd(\"ACL\").arg(\"HELP\")","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    // geospatial commands","highlight_start":1,"highlight_end":27},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Adds the specified geospatial items to the specified key.","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Every member has to be written as a tuple of `(longitude, latitude,","highlight_start":1,"highlight_end":76},{"text":"    /// member_name)`. It can be a single tuple, or a vector of tuples.","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `longitude, latitude` can be set using [`redis::geo::Coord`][1].","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [1]: ./geo/struct.Coord.html","highlight_start":1,"highlight_end":37},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Returns the number of elements added to the sorted set, not including","highlight_start":1,"highlight_end":78},{"text":"    /// elements already existing for which the score was updated.","highlight_start":1,"highlight_end":67},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Example","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, Connection, RedisResult};","highlight_start":1,"highlight_end":56},{"text":"    /// use redis::geo::Coord;","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn add_point(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":67},{"text":"    ///     con.geo_add(\"my_gis\", (Coord::lon_lat(13.361389, 38.115556), \"Palermo\"))","highlight_start":1,"highlight_end":85},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn add_point_with_tuples(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":79},{"text":"    ///     con.geo_add(\"my_gis\", (\"13.361389\", \"38.115556\", \"Palermo\"))","highlight_start":1,"highlight_end":73},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn add_many_points(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":73},{"text":"    ///     con.geo_add(\"my_gis\", &[","highlight_start":1,"highlight_end":37},{"text":"    ///         (\"13.361389\", \"38.115556\", \"Palermo\"),","highlight_start":1,"highlight_end":55},{"text":"    ///         (\"15.087269\", \"37.502669\", \"Catania\")","highlight_start":1,"highlight_end":54},{"text":"    ///     ])","highlight_start":1,"highlight_end":15},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_add<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"GEOADD\").arg(key).arg(members)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the distance between two members in the geospatial index","highlight_start":1,"highlight_end":72},{"text":"    /// represented by the sorted set.","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If one or both the members are missing, the command returns NULL, so","highlight_start":1,"highlight_end":77},{"text":"    /// it may be convenient to parse its response as either `Option<f64>` or","highlight_start":1,"highlight_end":78},{"text":"    /// `Option<String>`.","highlight_start":1,"highlight_end":26},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Example","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":44},{"text":"    /// use redis::geo::Unit;","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn get_dists(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":52},{"text":"    ///     let x: RedisResult<f64> = con.geo_dist(","highlight_start":1,"highlight_end":52},{"text":"    ///         \"my_gis\",","highlight_start":1,"highlight_end":26},{"text":"    ///         \"Palermo\",","highlight_start":1,"highlight_end":27},{"text":"    ///         \"Catania\",","highlight_start":1,"highlight_end":27},{"text":"    ///         Unit::Kilometers","highlight_start":1,"highlight_end":33},{"text":"    ///     );","highlight_start":1,"highlight_end":15},{"text":"    ///     // x is Ok(166.2742)","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///     let x: RedisResult<Option<f64>> = con.geo_dist(","highlight_start":1,"highlight_end":60},{"text":"    ///         \"my_gis\",","highlight_start":1,"highlight_end":26},{"text":"    ///         \"Palermo\",","highlight_start":1,"highlight_end":27},{"text":"    ///         \"Atlantis\",","highlight_start":1,"highlight_end":28},{"text":"    ///         Unit::Meters","highlight_start":1,"highlight_end":29},{"text":"    ///     );","highlight_start":1,"highlight_end":15},{"text":"    ///     // x is Ok(None)","highlight_start":1,"highlight_end":29},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_dist<K: ToRedisArgs, M1: ToRedisArgs, M2: ToRedisArgs>(","highlight_start":1,"highlight_end":67},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        member1: M1,","highlight_start":1,"highlight_end":21},{"text":"        member2: M2,","highlight_start":1,"highlight_end":21},{"text":"        unit: geo::Unit","highlight_start":1,"highlight_end":24},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"GEODIST\")","highlight_start":1,"highlight_end":23},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(member1)","highlight_start":1,"highlight_end":26},{"text":"            .arg(member2)","highlight_start":1,"highlight_end":26},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":23},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return valid [Geohash][1] strings representing the position of one or","highlight_start":1,"highlight_end":78},{"text":"    /// more members of the geospatial index represented by the sorted set at","highlight_start":1,"highlight_end":78},{"text":"    /// key.","highlight_start":1,"highlight_end":13},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [1]: https://en.wikipedia.org/wiki/Geohash","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Example","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn get_hash(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":51},{"text":"    ///     let x: RedisResult<Vec<String>> = con.geo_hash(\"my_gis\", \"Palermo\");","highlight_start":1,"highlight_end":81},{"text":"    ///     // x is vec![\"sqc8b49rny0\"]","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///     let x: RedisResult<Vec<String>> = con.geo_hash(\"my_gis\", &[\"Palermo\", \"Catania\"]);","highlight_start":1,"highlight_end":95},{"text":"    ///     // x is vec![\"sqc8b49rny0\", \"sqdtr74hyu0\"]","highlight_start":1,"highlight_end":55},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_hash<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"GEOHASH\").arg(key).arg(members)","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the positions of all the specified members of the geospatial","highlight_start":1,"highlight_end":76},{"text":"    /// index represented by the sorted set at key.","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Every position is a pair of `(longitude, latitude)`. [`redis::geo::Coord`][1]","highlight_start":1,"highlight_end":86},{"text":"    /// can be used to convert these value in a struct.","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [1]: ./geo/struct.Coord.html","highlight_start":1,"highlight_end":37},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Example","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":44},{"text":"    /// use redis::geo::Coord;","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn get_position(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":55},{"text":"    ///     let x: RedisResult<Vec<Vec<f64>>> = con.geo_pos(\"my_gis\", &[\"Palermo\", \"Catania\"]);","highlight_start":1,"highlight_end":96},{"text":"    ///     // x is [ [ 13.361389, 38.115556 ], [ 15.087269, 37.502669 ] ];","highlight_start":1,"highlight_end":76},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///     let x: Vec<Coord<f64>> = con.geo_pos(\"my_gis\", \"Palermo\").unwrap();","highlight_start":1,"highlight_end":80},{"text":"    ///     // x[0].longitude is 13.361389","highlight_start":1,"highlight_end":43},{"text":"    ///     // x[0].latitude is 38.115556","highlight_start":1,"highlight_end":42},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_pos<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"GEOPOS\").arg(key).arg(members)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the members of a sorted set populated with geospatial information","highlight_start":1,"highlight_end":81},{"text":"    /// using [`geo_add`](#method.geo_add), which are within the borders of the area","highlight_start":1,"highlight_end":85},{"text":"    /// specified with the center location and the maximum distance from the center","highlight_start":1,"highlight_end":84},{"text":"    /// (the radius).","highlight_start":1,"highlight_end":22},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Every item in the result can be read with [`redis::geo::RadiusSearchResult`][1],","highlight_start":1,"highlight_end":89},{"text":"    /// which support the multiple formats returned by `GEORADIUS`.","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [1]: ./geo/struct.RadiusSearchResult.html","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":44},{"text":"    /// use redis::geo::{RadiusOptions, RadiusSearchResult, RadiusOrder, Unit};","highlight_start":1,"highlight_end":80},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn radius(con: &mut redis::Connection) -> Vec<RadiusSearchResult> {","highlight_start":1,"highlight_end":76},{"text":"    ///     let opts = RadiusOptions::default().with_dist().order(RadiusOrder::Asc);","highlight_start":1,"highlight_end":85},{"text":"    ///     con.geo_radius(\"my_gis\", 15.90, 37.21, 51.39, Unit::Kilometers, opts).unwrap()","highlight_start":1,"highlight_end":91},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_radius<K: ToRedisArgs>(","highlight_start":1,"highlight_end":35},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        longitude: f64,","highlight_start":1,"highlight_end":24},{"text":"        latitude: f64,","highlight_start":1,"highlight_end":23},{"text":"        radius: f64,","highlight_start":1,"highlight_end":21},{"text":"        unit: geo::Unit,","highlight_start":1,"highlight_end":25},{"text":"        options: geo::RadiusOptions","highlight_start":1,"highlight_end":36},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"GEORADIUS\")","highlight_start":1,"highlight_end":25},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(longitude)","highlight_start":1,"highlight_end":28},{"text":"            .arg(latitude)","highlight_start":1,"highlight_end":27},{"text":"            .arg(radius)","highlight_start":1,"highlight_end":25},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":23},{"text":"            .arg(options)","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Retrieve members selected by distance with the center of `member`. The","highlight_start":1,"highlight_end":79},{"text":"    /// member itself is always contained in the results.","highlight_start":1,"highlight_end":58},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_radius_by_member<K: ToRedisArgs, M: ToRedisArgs>(","highlight_start":1,"highlight_end":61},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        member: M,","highlight_start":1,"highlight_end":19},{"text":"        radius: f64,","highlight_start":1,"highlight_end":21},{"text":"        unit: geo::Unit,","highlight_start":1,"highlight_end":25},{"text":"        options: geo::RadiusOptions","highlight_start":1,"highlight_end":36},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"GEORADIUSBYMEMBER\")","highlight_start":1,"highlight_end":33},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(member)","highlight_start":1,"highlight_end":25},{"text":"            .arg(radius)","highlight_start":1,"highlight_end":25},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":23},{"text":"            .arg(options)","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    // streams commands","highlight_start":1,"highlight_end":24},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Ack pending stream messages checked out by a consumer.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XACK <key> <group> <id> <id> ... <id>","highlight_start":1,"highlight_end":46},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xack<K: ToRedisArgs, G: ToRedisArgs, I: ToRedisArgs>(","highlight_start":1,"highlight_end":61},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        ids: &'a [I]) {","highlight_start":1,"highlight_end":24},{"text":"        cmd(\"XACK\")","highlight_start":1,"highlight_end":20},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add a stream message by `key`. Use `*` as the `id` for the current timestamp.","highlight_start":1,"highlight_end":86},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XADD key <ID or *> [field value] [field value] ...","highlight_start":1,"highlight_end":59},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xadd<K: ToRedisArgs, ID: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":78},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        id: ID,","highlight_start":1,"highlight_end":16},{"text":"        items: &'a [(F, V)]","highlight_start":1,"highlight_end":28},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XADD\").arg(key).arg(id).arg(items)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// BTreeMap variant for adding a stream message by `key`.","highlight_start":1,"highlight_end":63},{"text":"    /// Use `*` as the `id` for the current timestamp.","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XADD key <ID or *> [rust BTreeMap] ...","highlight_start":1,"highlight_end":47},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xadd_map<K: ToRedisArgs, ID: ToRedisArgs, BTM: ToRedisArgs>(","highlight_start":1,"highlight_end":68},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        id: ID,","highlight_start":1,"highlight_end":16},{"text":"        map: BTM","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XADD\").arg(key).arg(id).arg(map)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add a stream message while capping the stream at a maxlength.","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XADD key [MAXLEN [~|=] <count>] <ID or *> [field value] [field value] ...","highlight_start":1,"highlight_end":82},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xadd_maxlen<","highlight_start":1,"highlight_end":20},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        ID: ToRedisArgs,","highlight_start":1,"highlight_end":25},{"text":"        F: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        V: ToRedisArgs","highlight_start":1,"highlight_end":23},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        maxlen: streams::StreamMaxlen,","highlight_start":1,"highlight_end":39},{"text":"        id: ID,","highlight_start":1,"highlight_end":16},{"text":"        items: &'a [(F, V)]","highlight_start":1,"highlight_end":28},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XADD\")","highlight_start":1,"highlight_end":20},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(maxlen)","highlight_start":1,"highlight_end":25},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"            .arg(items)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// BTreeMap variant for adding a stream message while capping the stream at a maxlength.","highlight_start":1,"highlight_end":94},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XADD key [MAXLEN [~|=] <count>] <ID or *> [rust BTreeMap] ...","highlight_start":1,"highlight_end":70},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xadd_maxlen_map<K: ToRedisArgs, ID: ToRedisArgs, BTM: ToRedisArgs>(","highlight_start":1,"highlight_end":75},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        maxlen: streams::StreamMaxlen,","highlight_start":1,"highlight_end":39},{"text":"        id: ID,","highlight_start":1,"highlight_end":16},{"text":"        map: BTM","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XADD\")","highlight_start":1,"highlight_end":20},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(maxlen)","highlight_start":1,"highlight_end":25},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"            .arg(map)","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Claim pending, unacked messages, after some period of time,","highlight_start":1,"highlight_end":68},{"text":"    /// currently checked out by another consumer.","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method only accepts the must-have arguments for claiming messages.","highlight_start":1,"highlight_end":80},{"text":"    /// If optional arguments are required, see `xclaim_options` below.","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XCLAIM <key> <group> <consumer> <min-idle-time> [<ID-1> <ID-2>]","highlight_start":1,"highlight_end":72},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xclaim<K: ToRedisArgs, G: ToRedisArgs, C: ToRedisArgs, MIT: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":98},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        consumer: C,","highlight_start":1,"highlight_end":21},{"text":"        min_idle_time: MIT,","highlight_start":1,"highlight_end":28},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":22},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XCLAIM\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":27},{"text":"            .arg(min_idle_time)","highlight_start":1,"highlight_end":32},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the optional arguments version for claiming unacked, pending messages","highlight_start":1,"highlight_end":86},{"text":"    /// currently checked out by another consumer.","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```no_run","highlight_start":1,"highlight_end":18},{"text":"    /// use redis::{Connection,Commands,RedisResult};","highlight_start":1,"highlight_end":54},{"text":"    /// use redis::streams::{StreamClaimOptions,StreamClaimReply};","highlight_start":1,"highlight_end":67},{"text":"    /// let client = redis::Client::open(\"redis://127.0.0.1/0\").unwrap();","highlight_start":1,"highlight_end":74},{"text":"    /// let mut con = client.get_connection().unwrap();","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Claim all pending messages for key \"k1\",","highlight_start":1,"highlight_end":52},{"text":"    /// // from group \"g1\", checked out by consumer \"c1\"","highlight_start":1,"highlight_end":57},{"text":"    /// // for 10ms with RETRYCOUNT 2 and FORCE","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let opts = StreamClaimOptions::default()","highlight_start":1,"highlight_end":49},{"text":"    ///     .with_force()","highlight_start":1,"highlight_end":26},{"text":"    ///     .retry(2);","highlight_start":1,"highlight_end":23},{"text":"    /// let results: RedisResult<StreamClaimReply> =","highlight_start":1,"highlight_end":53},{"text":"    ///     con.xclaim_options(\"k1\", \"g1\", \"c1\", 10, &[\"0\"], opts);","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // All optional arguments return a `Result<StreamClaimReply>` with one exception:","highlight_start":1,"highlight_end":90},{"text":"    /// // Passing JUSTID returns only the message `id` and omits the HashMap for each message.","highlight_start":1,"highlight_end":96},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let opts = StreamClaimOptions::default()","highlight_start":1,"highlight_end":49},{"text":"    ///     .with_justid();","highlight_start":1,"highlight_end":28},{"text":"    /// let results: RedisResult<Vec<String>> =","highlight_start":1,"highlight_end":48},{"text":"    ///     con.xclaim_options(\"k1\", \"g1\", \"c1\", 10, &[\"0\"], opts);","highlight_start":1,"highlight_end":68},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2>","highlight_start":1,"highlight_end":70},{"text":"    ///     [IDLE <milliseconds>] [TIME <mstime>] [RETRYCOUNT <count>]","highlight_start":1,"highlight_end":71},{"text":"    ///     [FORCE] [JUSTID]","highlight_start":1,"highlight_end":29},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xclaim_options<","highlight_start":1,"highlight_end":23},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        C: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        MIT: ToRedisArgs,","highlight_start":1,"highlight_end":26},{"text":"        ID: ToRedisArgs","highlight_start":1,"highlight_end":24},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        consumer: C,","highlight_start":1,"highlight_end":21},{"text":"        min_idle_time: MIT,","highlight_start":1,"highlight_end":28},{"text":"        ids: &'a [ID],","highlight_start":1,"highlight_end":23},{"text":"        options: streams::StreamClaimOptions","highlight_start":1,"highlight_end":45},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XCLAIM\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":27},{"text":"            .arg(min_idle_time)","highlight_start":1,"highlight_end":32},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":22},{"text":"            .arg(options)","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Deletes a list of `id`s for a given stream `key`.","highlight_start":1,"highlight_end":58},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XDEL <key> [<ID1> <ID2> ... <IDN>]","highlight_start":1,"highlight_end":43},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xdel<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":46},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":22},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XDEL\").arg(key).arg(ids)","highlight_start":1,"highlight_end":38},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This command is used for creating a consumer `group`. It expects the stream key","highlight_start":1,"highlight_end":88},{"text":"    /// to already exist. Otherwise, use `xgroup_create_mkstream` if it doesn't.","highlight_start":1,"highlight_end":81},{"text":"    /// The `id` is the starting message id all consumers should read from. Use `$` If you want","highlight_start":1,"highlight_end":96},{"text":"    /// all consumers to read from the last message added to stream.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP CREATE <key> <groupname> <id or $>","highlight_start":1,"highlight_end":50},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_create<K: ToRedisArgs, G: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":71},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        id: ID","highlight_start":1,"highlight_end":15},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"CREATE\")","highlight_start":1,"highlight_end":27},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the alternate version for creating a consumer `group`","highlight_start":1,"highlight_end":70},{"text":"    /// which makes the stream if it doesn't exist.","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP CREATE <key> <groupname> <id or $> [MKSTREAM]","highlight_start":1,"highlight_end":61},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_create_mkstream<","highlight_start":1,"highlight_end":31},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        ID: ToRedisArgs","highlight_start":1,"highlight_end":24},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        id: ID","highlight_start":1,"highlight_end":15},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"CREATE\")","highlight_start":1,"highlight_end":27},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"            .arg(\"MKSTREAM\")","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Alter which `id` you want consumers to begin reading from an existing","highlight_start":1,"highlight_end":78},{"text":"    /// consumer `group`.","highlight_start":1,"highlight_end":26},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP SETID <key> <groupname> <id or $>","highlight_start":1,"highlight_end":49},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_setid<K: ToRedisArgs, G: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":70},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        id: ID","highlight_start":1,"highlight_end":15},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"SETID\")","highlight_start":1,"highlight_end":26},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Destroy an existing consumer `group` for a given stream `key`","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP SETID <key> <groupname> <id or $>","highlight_start":1,"highlight_end":49},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_destroy<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":55},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\").arg(\"DESTROY\").arg(key).arg(group)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This deletes a `consumer` from an existing consumer `group`","highlight_start":1,"highlight_end":68},{"text":"    /// for given stream `key.","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP DELCONSUMER <key> <groupname> <consumername>","highlight_start":1,"highlight_end":60},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_delconsumer<K: ToRedisArgs, G: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":75},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        consumer: C","highlight_start":1,"highlight_end":20},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"DELCONSUMER\")","highlight_start":1,"highlight_end":32},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This returns all info details about","highlight_start":1,"highlight_end":44},{"text":"    /// which consumers have read messages for given consumer `group`.","highlight_start":1,"highlight_end":71},{"text":"    /// Take note of the StreamInfoConsumersReply return type.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":70},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XINFO CONSUMERS <key> <group>","highlight_start":1,"highlight_end":38},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xinfo_consumers<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":56},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XINFO\")","highlight_start":1,"highlight_end":21},{"text":"            .arg(\"CONSUMERS\")","highlight_start":1,"highlight_end":30},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns all consumer `group`s created for a given stream `key`.","highlight_start":1,"highlight_end":72},{"text":"    /// Take note of the StreamInfoGroupsReply return type.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":70},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XINFO GROUPS <key>","highlight_start":1,"highlight_end":27},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xinfo_groups<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":46},{"text":"        cmd(\"XINFO\").arg(\"GROUPS\").arg(key)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns info about high-level stream details","highlight_start":1,"highlight_end":53},{"text":"    /// (first & last message `id`, length, number of groups, etc.)","highlight_start":1,"highlight_end":68},{"text":"    /// Take note of the StreamInfoStreamReply return type.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":70},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XINFO STREAM <key>","highlight_start":1,"highlight_end":27},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xinfo_stream<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":46},{"text":"        cmd(\"XINFO\").arg(\"STREAM\").arg(key)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the number of messages for a given stream `key`.","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XLEN <key>","highlight_start":1,"highlight_end":19},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"XLEN\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is a basic version of making XPENDING command calls which only","highlight_start":1,"highlight_end":76},{"text":"    /// passes a stream `key` and consumer `group` and it","highlight_start":1,"highlight_end":58},{"text":"    /// returns details about which consumers have pending messages","highlight_start":1,"highlight_end":68},{"text":"    /// that haven't been acked.","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// You can use this method along with","highlight_start":1,"highlight_end":43},{"text":"    /// `xclaim` or `xclaim_options` for determining which messages","highlight_start":1,"highlight_end":68},{"text":"    /// need to be retried.","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Take note of the StreamPendingReply return type.","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XPENDING <key> <group> [<start> <stop> <count> [<consumer>]]","highlight_start":1,"highlight_end":69},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xpending<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":49},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G","highlight_start":1,"highlight_end":17},{"text":"    )  {","highlight_start":1,"highlight_end":9},{"text":"        cmd(\"XPENDING\").arg(key).arg(group)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This XPENDING version returns a list of all messages over the range.","highlight_start":1,"highlight_end":77},{"text":"    /// You can use this for paginating pending messages (but without the message HashMap).","highlight_start":1,"highlight_end":92},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Start and end follow the same rules `xrange` args. Set start to `-`","highlight_start":1,"highlight_end":76},{"text":"    /// and end to `+` for the entire stream.","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Take note of the StreamPendingCountReply return type.","highlight_start":1,"highlight_end":62},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XPENDING <key> <group> <start> <stop> <count>","highlight_start":1,"highlight_end":54},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xpending_count<","highlight_start":1,"highlight_end":23},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        S: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        E: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        C: ToRedisArgs","highlight_start":1,"highlight_end":23},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        count: C","highlight_start":1,"highlight_end":17},{"text":"    )  {","highlight_start":1,"highlight_end":9},{"text":"        cmd(\"XPENDING\")","highlight_start":1,"highlight_end":24},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(start)","highlight_start":1,"highlight_end":24},{"text":"            .arg(end)","highlight_start":1,"highlight_end":22},{"text":"            .arg(count)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// An alternate version of `xpending_count` which filters by `consumer` name.","highlight_start":1,"highlight_end":83},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Start and end follow the same rules `xrange` args. Set start to `-`","highlight_start":1,"highlight_end":76},{"text":"    /// and end to `+` for the entire stream.","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Take note of the StreamPendingCountReply return type.","highlight_start":1,"highlight_end":62},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XPENDING <key> <group> <start> <stop> <count> <consumer>","highlight_start":1,"highlight_end":65},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xpending_consumer_count<","highlight_start":1,"highlight_end":32},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        S: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        E: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        C: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        CN: ToRedisArgs","highlight_start":1,"highlight_end":24},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        count: C,","highlight_start":1,"highlight_end":18},{"text":"        consumer: CN","highlight_start":1,"highlight_end":21},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XPENDING\")","highlight_start":1,"highlight_end":24},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(start)","highlight_start":1,"highlight_end":24},{"text":"            .arg(end)","highlight_start":1,"highlight_end":22},{"text":"            .arg(count)","highlight_start":1,"highlight_end":24},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns a range of messages in a given stream `key`.","highlight_start":1,"highlight_end":61},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Set `start` to `-` to begin at the first message.","highlight_start":1,"highlight_end":58},{"text":"    /// Set `end` to `+` to end the most recent message.","highlight_start":1,"highlight_end":57},{"text":"    /// You can pass message `id` to both `start` and `end`.","highlight_start":1,"highlight_end":61},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Take note of the StreamRangeReply return type.","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XRANGE key start end","highlight_start":1,"highlight_end":29},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrange<K: ToRedisArgs, S: ToRedisArgs, E: ToRedisArgs>(","highlight_start":1,"highlight_end":63},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        end: E","highlight_start":1,"highlight_end":15},{"text":"    )  {","highlight_start":1,"highlight_end":9},{"text":"        cmd(\"XRANGE\").arg(key).arg(start).arg(end)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// A helper method for automatically returning all messages in a stream by `key`.","highlight_start":1,"highlight_end":87},{"text":"    /// **Use with caution!**","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XRANGE key - +","highlight_start":1,"highlight_end":23},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrange_all<K: ToRedisArgs>(key: K)  {","highlight_start":1,"highlight_end":45},{"text":"        cmd(\"XRANGE\").arg(key).arg(\"-\").arg(\"+\")","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// A method for paginating a stream by `key`.","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XRANGE key start end [COUNT <n>]","highlight_start":1,"highlight_end":41},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrange_count<K: ToRedisArgs, S: ToRedisArgs, E: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":85},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        count: C","highlight_start":1,"highlight_end":17},{"text":"    )  {","highlight_start":1,"highlight_end":9},{"text":"        cmd(\"XRANGE\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(start)","highlight_start":1,"highlight_end":24},{"text":"            .arg(end)","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"COUNT\")","highlight_start":1,"highlight_end":26},{"text":"            .arg(count)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Read a list of `id`s for each stream `key`.","highlight_start":1,"highlight_end":52},{"text":"    /// This is the basic form of reading streams.","highlight_start":1,"highlight_end":51},{"text":"    /// For more advanced control, like blocking, limiting, or reading by consumer `group`,","highlight_start":1,"highlight_end":92},{"text":"    /// see `xread_options`.","highlight_start":1,"highlight_end":29},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREAD STREAMS key_1 key_2 ... key_N ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":63},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xread<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":47},{"text":"        keys: &'a [K],","highlight_start":1,"highlight_end":23},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":22},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XREAD\").arg(\"STREAMS\").arg(keys).arg(ids)","highlight_start":1,"highlight_end":55},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This method handles setting optional arguments for","highlight_start":1,"highlight_end":59},{"text":"    /// `XREAD` or `XREADGROUP` Redis commands.","highlight_start":1,"highlight_end":48},{"text":"    /// ```no_run","highlight_start":1,"highlight_end":18},{"text":"    /// use redis::{Connection,RedisResult,Commands};","highlight_start":1,"highlight_end":54},{"text":"    /// use redis::streams::{StreamReadOptions,StreamReadReply};","highlight_start":1,"highlight_end":65},{"text":"    /// let client = redis::Client::open(\"redis://127.0.0.1/0\").unwrap();","highlight_start":1,"highlight_end":74},{"text":"    /// let mut con = client.get_connection().unwrap();","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Read 10 messages from the start of the stream,","highlight_start":1,"highlight_end":58},{"text":"    /// // without registering as a consumer group.","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let opts = StreamReadOptions::default()","highlight_start":1,"highlight_end":48},{"text":"    ///     .count(10);","highlight_start":1,"highlight_end":24},{"text":"    /// let results: RedisResult<StreamReadReply> =","highlight_start":1,"highlight_end":52},{"text":"    ///     con.xread_options(&[\"k1\"], &[\"0\"], &opts);","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Read all undelivered messages for a given","highlight_start":1,"highlight_end":53},{"text":"    /// // consumer group. Be advised: the consumer group must already","highlight_start":1,"highlight_end":71},{"text":"    /// // exist before making this call. Also note: we're passing","highlight_start":1,"highlight_end":67},{"text":"    /// // '>' as the id here, which means all undelivered messages.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let opts = StreamReadOptions::default()","highlight_start":1,"highlight_end":48},{"text":"    ///     .group(\"group-1\", \"consumer-1\");","highlight_start":1,"highlight_end":45},{"text":"    /// let results: RedisResult<StreamReadReply> =","highlight_start":1,"highlight_end":52},{"text":"    ///     con.xread_options(&[\"k1\"], &[\">\"], &opts);","highlight_start":1,"highlight_end":55},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREAD [BLOCK <milliseconds>] [COUNT <count>]","highlight_start":1,"highlight_end":53},{"text":"    ///     STREAMS key_1 key_2 ... key_N","highlight_start":1,"highlight_end":42},{"text":"    ///     ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// XREADGROUP [BLOCK <milliseconds>] [COUNT <count>] [NOACK] [GROUP group-name consumer-name]","highlight_start":1,"highlight_end":99},{"text":"    ///     STREAMS key_1 key_2 ... key_N","highlight_start":1,"highlight_end":42},{"text":"    ///     ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":31},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xread_options<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":55},{"text":"        keys: &'a [K],","highlight_start":1,"highlight_end":23},{"text":"        ids: &'a [ID],","highlight_start":1,"highlight_end":23},{"text":"        options: &'a streams::StreamReadOptions","highlight_start":1,"highlight_end":48},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(if options.read_only() {","highlight_start":1,"highlight_end":37},{"text":"            \"XREAD\"","highlight_start":1,"highlight_end":20},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            \"XREADGROUP\"","highlight_start":1,"highlight_end":25},{"text":"        })","highlight_start":1,"highlight_end":11},{"text":"        .arg(options)","highlight_start":1,"highlight_end":22},{"text":"        .arg(\"STREAMS\")","highlight_start":1,"highlight_end":24},{"text":"        .arg(keys)","highlight_start":1,"highlight_end":19},{"text":"        .arg(ids)","highlight_start":1,"highlight_end":18},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange`.","highlight_start":1,"highlight_end":49},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREVRANGE key end start","highlight_start":1,"highlight_end":32},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrevrange<K: ToRedisArgs, E: ToRedisArgs, S: ToRedisArgs>(","highlight_start":1,"highlight_end":66},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        start: S","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XREVRANGE\").arg(key).arg(end).arg(start)","highlight_start":1,"highlight_end":54},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange_all`.","highlight_start":1,"highlight_end":53},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREVRANGE key + -","highlight_start":1,"highlight_end":26},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    fn xrevrange_all<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":47},{"text":"        cmd(\"XREVRANGE\").arg(key).arg(\"+\").arg(\"-\")","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange_count`.","highlight_start":1,"highlight_end":55},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREVRANGE key end start [COUNT <n>]","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrevrange_count<K: ToRedisArgs, E: ToRedisArgs, S: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":88},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        count: C","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XREVRANGE\")","highlight_start":1,"highlight_end":25},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(end)","highlight_start":1,"highlight_end":22},{"text":"            .arg(start)","highlight_start":1,"highlight_end":24},{"text":"            .arg(\"COUNT\")","highlight_start":1,"highlight_end":26},{"text":"            .arg(count)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Trim a stream `key` to a MAXLEN count.","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XTRIM <key> MAXLEN [~|=] <count>  (Same as XADD MAXLEN option)","highlight_start":1,"highlight_end":71},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xtrim<K: ToRedisArgs>(","highlight_start":1,"highlight_end":30},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        maxlen: streams::StreamMaxlen","highlight_start":1,"highlight_end":38},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XTRIM\").arg(key).arg(maxlen)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"implement_commands!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/macros.rs","byte_start":0,"byte_end":31,"line_start":1,"line_end":1,"column_start":1,"column_end":32,"is_primary":false,"text":[{"text":"macro_rules! implement_commands {","highlight_start":1,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `!: FromRedisValue` is not satisfied\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:49:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m49\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        conn.set_ex(&session_id, session_json, SESSION_TTL).await?;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `FromRedisValue` is not implemented for `!`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `FromRedisValue`:\u001b[0m\n\u001b[0m               ()\u001b[0m\n\u001b[0m               (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m               (T10, T11, T12)\u001b[0m\n\u001b[0m               (T11, T12)\u001b[0m\n\u001b[0m               (T12,)\u001b[0m\n\u001b[0m               (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m               (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m               (T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m             and 42 others\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: did you intend to use the type `()` here instead?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `redis::AsyncCommands::set_ex`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/mod.rs:41:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimplement_commands! {\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    'a\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m83\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn set_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, seconds: usize) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this associated function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1847\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `AsyncCommands::set_ex`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `implement_commands` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `!: FromRedisValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/auth.rs","byte_start":2590,"byte_end":2596,"line_start":84,"line_end":84,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"        conn.expire(session_id, SESSION_TTL).await?;","highlight_start":14,"highlight_end":20}],"label":"the trait `FromRedisValue` is not implemented for `!`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `FromRedisValue`:\n  ()\n  (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T10, T11, T12)\n  (T11, T12)\n  (T12,)\n  (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\n  (T4, T5, T6, T7, T8, T9, T10, T11, T12)\nand 42 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"did you intend to use the type `()` here instead?","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `redis::AsyncCommands::expire`","code":null,"level":"note","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/mod.rs","byte_start":5196,"byte_end":5202,"line_start":133,"line_end":133,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn expire<K: ToRedisArgs>(key: K, seconds: usize) {","highlight_start":8,"highlight_end":14}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/macros.rs","byte_start":7006,"byte_end":7020,"line_start":167,"line_end":167,"column_start":25,"column_end":39,"is_primary":true,"text":[{"text":"                    RV: FromRedisValue,","highlight_start":25,"highlight_end":39}],"label":"required by this bound in `AsyncCommands::expire`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/mod.rs","byte_start":2151,"byte_end":64581,"line_start":41,"line_end":1847,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"implement_commands! {","highlight_start":1,"highlight_end":22},{"text":"    'a","highlight_start":1,"highlight_end":7},{"text":"    // most common operations","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key.  If key is a vec this becomes an `MGET`.","highlight_start":1,"highlight_end":73},{"text":"    fn get<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":37},{"text":"        cmd(if key.is_single_arg() { \"GET\" } else { \"MGET\" }).arg(key)","highlight_start":1,"highlight_end":71},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get values of keys","highlight_start":1,"highlight_end":27},{"text":"    fn mget<K: ToRedisArgs>(key: K){","highlight_start":1,"highlight_end":37},{"text":"        cmd(\"MGET\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all keys matching pattern","highlight_start":1,"highlight_end":39},{"text":"    fn keys<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"KEYS\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key.","highlight_start":1,"highlight_end":39},{"text":"    fn set<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":63},{"text":"        cmd(\"SET\").arg(key).arg(value)","highlight_start":1,"highlight_end":39},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key with options.","highlight_start":1,"highlight_end":52},{"text":"    fn set_options<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, options: SetOptions) {","highlight_start":1,"highlight_end":92},{"text":"        cmd(\"SET\").arg(key).arg(value).arg(options)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values.","highlight_start":1,"highlight_end":44},{"text":"    #[allow(deprecated)]","highlight_start":1,"highlight_end":25},{"text":"    #[deprecated(since = \"0.22.4\", note = \"Renamed to mset() to reflect Redis name\")]","highlight_start":1,"highlight_end":86},{"text":"    fn set_multiple<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":75},{"text":"        cmd(\"MSET\").arg(items)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values.","highlight_start":1,"highlight_end":44},{"text":"    fn mset<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"MSET\").arg(items)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value and expiration of a key.","highlight_start":1,"highlight_end":47},{"text":"    fn set_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, seconds: usize) {","highlight_start":1,"highlight_end":82},{"text":"        cmd(\"SETEX\").arg(key).arg(seconds).arg(value)","highlight_start":1,"highlight_end":54},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value and expiration in milliseconds of a key.","highlight_start":1,"highlight_end":63},{"text":"    fn pset_ex<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, milliseconds: usize) {","highlight_start":1,"highlight_end":88},{"text":"        cmd(\"PSETEX\").arg(key).arg(milliseconds).arg(value)","highlight_start":1,"highlight_end":60},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the value of a key, only if the key does not exist","highlight_start":1,"highlight_end":63},{"text":"    fn set_nx<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"SETNX\").arg(key).arg(value)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets multiple keys to their values failing if at least one already exists.","highlight_start":1,"highlight_end":83},{"text":"    fn mset_nx<K: ToRedisArgs, V: ToRedisArgs>(items: &'a [(K, V)]) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"MSETNX\").arg(items)","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the string value of a key and return its old value.","highlight_start":1,"highlight_end":64},{"text":"    fn getset<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"GETSET\").arg(key).arg(value)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get a range of bytes/substring from the value of a key. Negative values provide an offset from the end of the value.","highlight_start":1,"highlight_end":125},{"text":"    fn getrange<K: ToRedisArgs>(key: K, from: isize, to: isize) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"GETRANGE\").arg(key).arg(from).arg(to)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Overwrite the part of the value stored in key at the specified offset.","highlight_start":1,"highlight_end":79},{"text":"    fn setrange<K: ToRedisArgs, V: ToRedisArgs>(key: K, offset: isize, value: V) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"SETRANGE\").arg(key).arg(offset).arg(value)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Delete one or more keys.","highlight_start":1,"highlight_end":33},{"text":"    fn del<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":37},{"text":"        cmd(\"DEL\").arg(key)","highlight_start":1,"highlight_end":28},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine if a key exists.","highlight_start":1,"highlight_end":35},{"text":"    fn exists<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":40},{"text":"        cmd(\"EXISTS\").arg(key)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the type of a key.","highlight_start":1,"highlight_end":37},{"text":"    fn key_type<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"TYPE\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set a key's time to live in seconds.","highlight_start":1,"highlight_end":45},{"text":"    fn expire<K: ToRedisArgs>(key: K, seconds: usize) {","highlight_start":1,"highlight_end":56},{"text":"        cmd(\"EXPIRE\").arg(key).arg(seconds)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the expiration for a key as a UNIX timestamp.","highlight_start":1,"highlight_end":58},{"text":"    fn expire_at<K: ToRedisArgs>(key: K, ts: usize) {","highlight_start":1,"highlight_end":54},{"text":"        cmd(\"EXPIREAT\").arg(key).arg(ts)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set a key's time to live in milliseconds.","highlight_start":1,"highlight_end":50},{"text":"    fn pexpire<K: ToRedisArgs>(key: K, ms: usize) {","highlight_start":1,"highlight_end":52},{"text":"        cmd(\"PEXPIRE\").arg(key).arg(ms)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Set the expiration for a key as a UNIX timestamp in milliseconds.","highlight_start":1,"highlight_end":74},{"text":"    fn pexpire_at<K: ToRedisArgs>(key: K, ts: usize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"PEXPIREAT\").arg(key).arg(ts)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove the expiration from a key.","highlight_start":1,"highlight_end":42},{"text":"    fn persist<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"PERSIST\").arg(key)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the expiration time of a key.","highlight_start":1,"highlight_end":42},{"text":"    fn ttl<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":37},{"text":"        cmd(\"TTL\").arg(key)","highlight_start":1,"highlight_end":28},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the expiration time of a key in milliseconds.","highlight_start":1,"highlight_end":58},{"text":"    fn pttl<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"PTTL\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key and set expiration","highlight_start":1,"highlight_end":50},{"text":"    fn get_ex<K: ToRedisArgs>(key: K, expire_at: Expiry) {","highlight_start":1,"highlight_end":59},{"text":"        let (option, time_arg) = match expire_at {","highlight_start":1,"highlight_end":51},{"text":"            Expiry::EX(sec) => (\"EX\", Some(sec)),","highlight_start":1,"highlight_end":50},{"text":"            Expiry::PX(ms) => (\"PX\", Some(ms)),","highlight_start":1,"highlight_end":48},{"text":"            Expiry::EXAT(timestamp_sec) => (\"EXAT\", Some(timestamp_sec)),","highlight_start":1,"highlight_end":74},{"text":"            Expiry::PXAT(timestamp_ms) => (\"PXAT\", Some(timestamp_ms)),","highlight_start":1,"highlight_end":72},{"text":"            Expiry::PERSIST => (\"PERSIST\", None),","highlight_start":1,"highlight_end":50},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        cmd(\"GETEX\").arg(key).arg(option).arg(time_arg)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the value of a key and delete it","highlight_start":1,"highlight_end":45},{"text":"    fn get_del<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"GETDEL\").arg(key)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Rename a key.","highlight_start":1,"highlight_end":22},{"text":"    fn rename<K: ToRedisArgs, N: ToRedisArgs>(key: K, new_key: N) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"RENAME\").arg(key).arg(new_key)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Rename a key, only if the new key does not exist.","highlight_start":1,"highlight_end":58},{"text":"    fn rename_nx<K: ToRedisArgs, N: ToRedisArgs>(key: K, new_key: N) {","highlight_start":1,"highlight_end":71},{"text":"        cmd(\"RENAMENX\").arg(key).arg(new_key)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unlink one or more keys.","highlight_start":1,"highlight_end":33},{"text":"    fn unlink<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":40},{"text":"        cmd(\"UNLINK\").arg(key)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // common string operations","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Append a value to a key.","highlight_start":1,"highlight_end":33},{"text":"    fn append<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"APPEND\").arg(key).arg(value)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increment the numeric value of a key by the given amount.  This","highlight_start":1,"highlight_end":72},{"text":"    /// issues a `INCRBY` or `INCRBYFLOAT` depending on the type.","highlight_start":1,"highlight_end":66},{"text":"    fn incr<K: ToRedisArgs, V: ToRedisArgs>(key: K, delta: V) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(if delta.describe_numeric_behavior() == NumericBehavior::NumberIsFloat {","highlight_start":1,"highlight_end":85},{"text":"            \"INCRBYFLOAT\"","highlight_start":1,"highlight_end":26},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            \"INCRBY\"","highlight_start":1,"highlight_end":21},{"text":"        }).arg(key).arg(delta)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Decrement the numeric value of a key by the given amount.","highlight_start":1,"highlight_end":66},{"text":"    fn decr<K: ToRedisArgs, V: ToRedisArgs>(key: K, delta: V) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(\"DECRBY\").arg(key).arg(delta)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets or clears the bit at offset in the string value stored at key.","highlight_start":1,"highlight_end":76},{"text":"    fn setbit<K: ToRedisArgs>(key: K, offset: usize, value: bool) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"SETBIT\").arg(key).arg(offset).arg(i32::from(value))","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the bit value at offset in the string value stored at key.","highlight_start":1,"highlight_end":75},{"text":"    fn getbit<K: ToRedisArgs>(key: K, offset: usize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"GETBIT\").arg(key).arg(offset)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count set bits in a string.","highlight_start":1,"highlight_end":36},{"text":"    fn bitcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"BITCOUNT\").arg(key)","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count set bits in a string in a range.","highlight_start":1,"highlight_end":47},{"text":"    fn bitcount_range<K: ToRedisArgs>(key: K, start: usize, end: usize) {","highlight_start":1,"highlight_end":74},{"text":"        cmd(\"BITCOUNT\").arg(key).arg(start).arg(end)","highlight_start":1,"highlight_end":53},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise AND between multiple keys (containing string values)","highlight_start":1,"highlight_end":79},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":53},{"text":"    fn bit_and<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"BITOP\").arg(\"AND\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise OR between multiple keys (containing string values)","highlight_start":1,"highlight_end":78},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":53},{"text":"    fn bit_or<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":71},{"text":"        cmd(\"BITOP\").arg(\"OR\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise XOR between multiple keys (containing string values)","highlight_start":1,"highlight_end":79},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":53},{"text":"    fn bit_xor<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"BITOP\").arg(\"XOR\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Perform a bitwise NOT of the key (containing string values)","highlight_start":1,"highlight_end":68},{"text":"    /// and store the result in the destination key.","highlight_start":1,"highlight_end":53},{"text":"    fn bit_not<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckey: S) {","highlight_start":1,"highlight_end":71},{"text":"        cmd(\"BITOP\").arg(\"NOT\").arg(dstkey).arg(srckey)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the length of the value stored in a key.","highlight_start":1,"highlight_end":53},{"text":"    fn strlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":40},{"text":"        cmd(\"STRLEN\").arg(key)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // hash operations","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets a single (or multiple) fields from a hash.","highlight_start":1,"highlight_end":56},{"text":"    fn hget<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(if field.is_single_arg() { \"HGET\" } else { \"HMGET\" }).arg(key).arg(field)","highlight_start":1,"highlight_end":86},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Deletes a single (or multiple) fields from a hash.","highlight_start":1,"highlight_end":59},{"text":"    fn hdel<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(\"HDEL\").arg(key).arg(field)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a single field in a hash.","highlight_start":1,"highlight_end":39},{"text":"    fn hset<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, field: F, value: V) {","highlight_start":1,"highlight_end":90},{"text":"        cmd(\"HSET\").arg(key).arg(field).arg(value)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a single field in a hash if it does not exist.","highlight_start":1,"highlight_end":60},{"text":"    fn hset_nx<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, field: F, value: V) {","highlight_start":1,"highlight_end":93},{"text":"        cmd(\"HSETNX\").arg(key).arg(field).arg(value)","highlight_start":1,"highlight_end":53},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets a multiple fields in a hash.","highlight_start":1,"highlight_end":42},{"text":"    fn hset_multiple<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(key: K, items: &'a [(F, V)]) {","highlight_start":1,"highlight_end":100},{"text":"        cmd(\"HMSET\").arg(key).arg(items)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increments a value.","highlight_start":1,"highlight_end":28},{"text":"    fn hincr<K: ToRedisArgs, F: ToRedisArgs, D: ToRedisArgs>(key: K, field: F, delta: D) {","highlight_start":1,"highlight_end":91},{"text":"        cmd(if delta.describe_numeric_behavior() == NumericBehavior::NumberIsFloat {","highlight_start":1,"highlight_end":85},{"text":"            \"HINCRBYFLOAT\"","highlight_start":1,"highlight_end":27},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            \"HINCRBY\"","highlight_start":1,"highlight_end":22},{"text":"        }).arg(key).arg(field).arg(delta)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Checks if a field in a hash exists.","highlight_start":1,"highlight_end":44},{"text":"    fn hexists<K: ToRedisArgs, F: ToRedisArgs>(key: K, field: F) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"HEXISTS\").arg(key).arg(field)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the keys in a hash.","highlight_start":1,"highlight_end":37},{"text":"    fn hkeys<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":39},{"text":"        cmd(\"HKEYS\").arg(key)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the values in a hash.","highlight_start":1,"highlight_end":39},{"text":"    fn hvals<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":39},{"text":"        cmd(\"HVALS\").arg(key)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets all the fields and values in a hash.","highlight_start":1,"highlight_end":50},{"text":"    fn hgetall<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"HGETALL\").arg(key)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Gets the length of a hash.","highlight_start":1,"highlight_end":35},{"text":"    fn hlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"HLEN\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // list operations","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop an element from a list, push it to another list","highlight_start":1,"highlight_end":60},{"text":"    /// and return it; or block until one is available","highlight_start":1,"highlight_end":55},{"text":"    fn blmove<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, src_dir: Direction, dst_dir: Direction, timeout: usize) {","highlight_start":1,"highlight_end":126},{"text":"        cmd(\"BLMOVE\").arg(srckey).arg(dstkey).arg(src_dir).arg(dst_dir).arg(timeout)","highlight_start":1,"highlight_end":85},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pops `count` elements from the first non-empty list key from the list of","highlight_start":1,"highlight_end":81},{"text":"    /// provided key names; or blocks until one is available.","highlight_start":1,"highlight_end":62},{"text":"    fn blmpop<K: ToRedisArgs>(timeout: usize, numkeys: usize, key: K, dir: Direction, count: usize){","highlight_start":1,"highlight_end":101},{"text":"        cmd(\"BLMPOP\").arg(timeout).arg(numkeys).arg(key).arg(dir).arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":90},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and get the first element in a list, or block until one is available.","highlight_start":1,"highlight_end":85},{"text":"    fn blpop<K: ToRedisArgs>(key: K, timeout: usize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"BLPOP\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and get the last element in a list, or block until one is available.","highlight_start":1,"highlight_end":84},{"text":"    fn brpop<K: ToRedisArgs>(key: K, timeout: usize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"BRPOP\").arg(key).arg(timeout)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop a value from a list, push it to another list and return it;","highlight_start":1,"highlight_end":72},{"text":"    /// or block until one is available.","highlight_start":1,"highlight_end":41},{"text":"    fn brpoplpush<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, timeout: usize) {","highlight_start":1,"highlight_end":90},{"text":"        cmd(\"BRPOPLPUSH\").arg(srckey).arg(dstkey).arg(timeout)","highlight_start":1,"highlight_end":63},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get an element from a list by its index.","highlight_start":1,"highlight_end":49},{"text":"    fn lindex<K: ToRedisArgs>(key: K, index: isize) {","highlight_start":1,"highlight_end":54},{"text":"        cmd(\"LINDEX\").arg(key).arg(index)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert an element before another element in a list.","highlight_start":1,"highlight_end":60},{"text":"    fn linsert_before<K: ToRedisArgs, P: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":71},{"text":"            key: K, pivot: P, value: V) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"LINSERT\").arg(key).arg(\"BEFORE\").arg(pivot).arg(value)","highlight_start":1,"highlight_end":68},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert an element after another element in a list.","highlight_start":1,"highlight_end":59},{"text":"    fn linsert_after<K: ToRedisArgs, P: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":70},{"text":"            key: K, pivot: P, value: V) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"LINSERT\").arg(key).arg(\"AFTER\").arg(pivot).arg(value)","highlight_start":1,"highlight_end":67},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the length of the list stored at key.","highlight_start":1,"highlight_end":54},{"text":"    fn llen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"LLEN\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop an element a list, push it to another list and return it","highlight_start":1,"highlight_end":69},{"text":"    fn lmove<S: ToRedisArgs, D: ToRedisArgs>(srckey: S, dstkey: D, src_dir: Direction, dst_dir: Direction) {","highlight_start":1,"highlight_end":109},{"text":"        cmd(\"LMOVE\").arg(srckey).arg(dstkey).arg(src_dir).arg(dst_dir)","highlight_start":1,"highlight_end":71},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pops `count` elements from the first non-empty list key from the list of","highlight_start":1,"highlight_end":81},{"text":"    /// provided key names.","highlight_start":1,"highlight_end":28},{"text":"    fn lmpop<K: ToRedisArgs>( numkeys: usize, key: K, dir: Direction, count: usize) {","highlight_start":1,"highlight_end":86},{"text":"        cmd(\"LMPOP\").arg(numkeys).arg(key).arg(dir).arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":76},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the up to `count` first elements of the list stored at key.","highlight_start":1,"highlight_end":88},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If `count` is not specified, then defaults to first element.","highlight_start":1,"highlight_end":69},{"text":"    fn lpop<K: ToRedisArgs>(key: K, count: Option<core::num::NonZeroUsize>) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"LPOP\").arg(key).arg(count)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the index of the first matching value of the list stored at key.","highlight_start":1,"highlight_end":81},{"text":"    fn lpos<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V, options: LposOptions) {","highlight_start":1,"highlight_end":86},{"text":"        cmd(\"LPOS\").arg(key).arg(value).arg(options)","highlight_start":1,"highlight_end":53},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert all the specified values at the head of the list stored at key.","highlight_start":1,"highlight_end":79},{"text":"    fn lpush<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":65},{"text":"        cmd(\"LPUSH\").arg(key).arg(value)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Inserts a value at the head of the list stored at key, only if key","highlight_start":1,"highlight_end":75},{"text":"    /// already exists and holds a list.","highlight_start":1,"highlight_end":41},{"text":"    fn lpush_exists<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"LPUSHX\").arg(key).arg(value)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the specified elements of the list stored at key.","highlight_start":1,"highlight_end":66},{"text":"    fn lrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"LRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes the first count occurrences of elements equal to value","highlight_start":1,"highlight_end":71},{"text":"    /// from the list stored at key.","highlight_start":1,"highlight_end":37},{"text":"    fn lrem<K: ToRedisArgs, V: ToRedisArgs>(key: K, count: isize, value: V) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"LREM\").arg(key).arg(count).arg(value)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Trim an existing list so that it will contain only the specified","highlight_start":1,"highlight_end":73},{"text":"    /// range of elements specified.","highlight_start":1,"highlight_end":37},{"text":"    fn ltrim<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"LTRIM\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sets the list element at index to value","highlight_start":1,"highlight_end":48},{"text":"    fn lset<K: ToRedisArgs, V: ToRedisArgs>(key: K, index: isize, value: V) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"LSET\").arg(key).arg(index).arg(value)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns the up to `count` last elements of the list stored at key","highlight_start":1,"highlight_end":86},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If `count` is not specified, then defaults to last element.","highlight_start":1,"highlight_end":68},{"text":"    fn rpop<K: ToRedisArgs>(key: K, count: Option<core::num::NonZeroUsize>) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"RPOP\").arg(key).arg(count)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Pop a value from a list, push it to another list and return it.","highlight_start":1,"highlight_end":72},{"text":"    fn rpoplpush<K: ToRedisArgs, D: ToRedisArgs>(key: K, dstkey: D) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"RPOPLPUSH\").arg(key).arg(dstkey)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Insert all the specified values at the tail of the list stored at key.","highlight_start":1,"highlight_end":79},{"text":"    fn rpush<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":65},{"text":"        cmd(\"RPUSH\").arg(key).arg(value)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Inserts value at the tail of the list stored at key, only if key","highlight_start":1,"highlight_end":73},{"text":"    /// already exists and holds a list.","highlight_start":1,"highlight_end":41},{"text":"    fn rpush_exists<K: ToRedisArgs, V: ToRedisArgs>(key: K, value: V) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"RPUSHX\").arg(key).arg(value)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // set commands","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add one or more members to a set.","highlight_start":1,"highlight_end":42},{"text":"    fn sadd<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":65},{"text":"        cmd(\"SADD\").arg(key).arg(member)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the number of members in a set.","highlight_start":1,"highlight_end":44},{"text":"    fn scard<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":39},{"text":"        cmd(\"SCARD\").arg(key)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Subtract multiple sets.","highlight_start":1,"highlight_end":32},{"text":"    fn sdiff<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":40},{"text":"        cmd(\"SDIFF\").arg(keys)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Subtract multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":69},{"text":"    fn sdiffstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"SDIFFSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sets.","highlight_start":1,"highlight_end":33},{"text":"    fn sinter<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"SINTER\").arg(keys)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":70},{"text":"    fn sinterstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":73},{"text":"        cmd(\"SINTERSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine if a given value is a member of a set.","highlight_start":1,"highlight_end":57},{"text":"    fn sismember<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"SISMEMBER\").arg(key).arg(member)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get all the members in a set.","highlight_start":1,"highlight_end":38},{"text":"    fn smembers<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":42},{"text":"        cmd(\"SMEMBERS\").arg(key)","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Move a member from one set to another.","highlight_start":1,"highlight_end":47},{"text":"    fn smove<S: ToRedisArgs, D: ToRedisArgs, M: ToRedisArgs>(srckey: S, dstkey: D, member: M) {","highlight_start":1,"highlight_end":96},{"text":"        cmd(\"SMOVE\").arg(srckey).arg(dstkey).arg(member)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove and return a random member from a set.","highlight_start":1,"highlight_end":54},{"text":"    fn spop<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"SPOP\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get one random member from a set.","highlight_start":1,"highlight_end":42},{"text":"    fn srandmember<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":45},{"text":"        cmd(\"SRANDMEMBER\").arg(key)","highlight_start":1,"highlight_end":36},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get multiple random members from a set.","highlight_start":1,"highlight_end":48},{"text":"    fn srandmember_multiple<K: ToRedisArgs>(key: K, count: usize) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"SRANDMEMBER\").arg(key).arg(count)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove one or more members from a set.","highlight_start":1,"highlight_end":47},{"text":"    fn srem<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":65},{"text":"        cmd(\"SREM\").arg(key).arg(member)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple sets.","highlight_start":1,"highlight_end":27},{"text":"    fn sunion<K: ToRedisArgs>(keys: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"SUNION\").arg(keys)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple sets and store the resulting set in a key.","highlight_start":1,"highlight_end":64},{"text":"    fn sunionstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: K) {","highlight_start":1,"highlight_end":73},{"text":"        cmd(\"SUNIONSTORE\").arg(dstkey).arg(keys)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // sorted set commands","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add one member to a sorted set, or update its score if it already exists.","highlight_start":1,"highlight_end":82},{"text":"    fn zadd<K: ToRedisArgs, S: ToRedisArgs, M: ToRedisArgs>(key: K, member: M, score: S) {","highlight_start":1,"highlight_end":91},{"text":"        cmd(\"ZADD\").arg(key).arg(score).arg(member)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add multiple members to a sorted set, or update its score if it already exists.","highlight_start":1,"highlight_end":88},{"text":"    fn zadd_multiple<K: ToRedisArgs, S: ToRedisArgs, M: ToRedisArgs>(key: K, items: &'a [(S, M)]) {","highlight_start":1,"highlight_end":100},{"text":"        cmd(\"ZADD\").arg(key).arg(items)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the number of members in a sorted set.","highlight_start":1,"highlight_end":51},{"text":"    fn zcard<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":39},{"text":"        cmd(\"ZCARD\").arg(key)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count the members in a sorted set with scores within the given values.","highlight_start":1,"highlight_end":79},{"text":"    fn zcount<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":90},{"text":"        cmd(\"ZCOUNT\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Increments the member in a sorted set at key by delta.","highlight_start":1,"highlight_end":63},{"text":"    /// If the member does not exist, it is added with delta as its score.","highlight_start":1,"highlight_end":75},{"text":"    fn zincr<K: ToRedisArgs, M: ToRedisArgs, D: ToRedisArgs>(key: K, member: M, delta: D) {","highlight_start":1,"highlight_end":92},{"text":"        cmd(\"ZINCRBY\").arg(key).arg(delta).arg(member)","highlight_start":1,"highlight_end":55},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":77},{"text":"    /// a new key using SUM as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zinterstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":79},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys)","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":77},{"text":"    /// a new key using MIN as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zinterstore_min<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\")","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Intersect multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":77},{"text":"    /// a new key using MAX as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zinterstore_max<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\")","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore`], but with the ability to specify a","highlight_start":1,"highlight_end":69},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zinterstore_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":108},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore_min`], but with the ability to specify a","highlight_start":1,"highlight_end":73},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zinterstore_min_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":112},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":121},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zinterstore_max`], but with the ability to specify a","highlight_start":1,"highlight_end":73},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zinterstore_max_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":112},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZINTERSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":121},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Count the number of members in a sorted set between a given lexicographical range.","highlight_start":1,"highlight_end":91},{"text":"    fn zlexcount<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":93},{"text":"        cmd(\"ZLEXCOUNT\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the highest scores in a sorted set","highlight_start":1,"highlight_end":88},{"text":"    fn zpopmax<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"ZPOPMAX\").arg(key).arg(count)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the lowest scores in a sorted set","highlight_start":1,"highlight_end":87},{"text":"    fn zpopmin<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":55},{"text":"        cmd(\"ZPOPMIN\").arg(key).arg(count)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the highest scores,","highlight_start":1,"highlight_end":73},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":79},{"text":"    fn zmpop_max<K: ToRedisArgs>(keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(\"ZMPOP\").arg(keys.len()).arg(keys).arg(\"MAX\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":82},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Removes and returns up to count members with the lowest scores,","highlight_start":1,"highlight_end":72},{"text":"    /// from the first non-empty sorted set in the provided list of key names.","highlight_start":1,"highlight_end":79},{"text":"    fn zmpop_min<K: ToRedisArgs>(keys: &'a [K], count: isize) {","highlight_start":1,"highlight_end":64},{"text":"        cmd(\"ZMPOP\").arg(keys.len()).arg(keys).arg(\"MIN\").arg(\"COUNT\").arg(count)","highlight_start":1,"highlight_end":82},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return up to count random members in a sorted set (or 1 if `count == None`)","highlight_start":1,"highlight_end":84},{"text":"    fn zrandmember<K: ToRedisArgs>(key: K, count: Option<isize>) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"ZRANDMEMBER\").arg(key).arg(count)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return up to count random members in a sorted set with scores","highlight_start":1,"highlight_end":70},{"text":"    fn zrandmember_withscores<K: ToRedisArgs>(key: K, count: isize) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"ZRANDMEMBER\").arg(key).arg(count).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index","highlight_start":1,"highlight_end":60},{"text":"    fn zrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"ZRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index with scores.","highlight_start":1,"highlight_end":73},{"text":"    fn zrange_withscores<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":78},{"text":"        cmd(\"ZRANGE\").arg(key).arg(start).arg(stop).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":70},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical range.","highlight_start":1,"highlight_end":77},{"text":"    fn zrangebylex<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":95},{"text":"        cmd(\"ZRANGEBYLEX\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":54},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical","highlight_start":1,"highlight_end":70},{"text":"    /// range with offset and limit.","highlight_start":1,"highlight_end":37},{"text":"    fn zrangebylex_limit<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(","highlight_start":1,"highlight_end":75},{"text":"            key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"ZRANGEBYLEX\").arg(key).arg(min).arg(max).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":90},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical range.","highlight_start":1,"highlight_end":77},{"text":"    fn zrevrangebylex<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":98},{"text":"        cmd(\"ZREVRANGEBYLEX\").arg(key).arg(max).arg(min)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by lexicographical","highlight_start":1,"highlight_end":70},{"text":"    /// range with offset and limit.","highlight_start":1,"highlight_end":37},{"text":"    fn zrevrangebylex_limit<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(","highlight_start":1,"highlight_end":78},{"text":"            key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":68},{"text":"        cmd(\"ZREVRANGEBYLEX\").arg(key).arg(max).arg(min).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score.","highlight_start":1,"highlight_end":61},{"text":"    fn zrangebyscore<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":97},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with scores.","highlight_start":1,"highlight_end":73},{"text":"    fn zrangebyscore_withscores<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":108},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":74},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit.","highlight_start":1,"highlight_end":72},{"text":"    fn zrangebyscore_limit<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>","highlight_start":1,"highlight_end":76},{"text":"            (key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":92},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit with scores.","highlight_start":1,"highlight_end":84},{"text":"    fn zrangebyscore_limit_withscores<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>","highlight_start":1,"highlight_end":87},{"text":"            (key: K, min: M, max: MM, offset: isize, count: isize) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZRANGEBYSCORE\").arg(key).arg(min).arg(max).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":74},{"text":"            .arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the index of a member in a sorted set.","highlight_start":1,"highlight_end":57},{"text":"    fn zrank<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"ZRANK\").arg(key).arg(member)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove one or more members from a sorted set.","highlight_start":1,"highlight_end":54},{"text":"    fn zrem<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":66},{"text":"        cmd(\"ZREM\").arg(key).arg(members)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set between the given lexicographical range.","highlight_start":1,"highlight_end":84},{"text":"    fn zrembylex<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":93},{"text":"        cmd(\"ZREMRANGEBYLEX\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set within the given indexes.","highlight_start":1,"highlight_end":69},{"text":"    fn zremrangebyrank<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":76},{"text":"        cmd(\"ZREMRANGEBYRANK\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Remove all members in a sorted set within the given scores.","highlight_start":1,"highlight_end":68},{"text":"    fn zrembyscore<K: ToRedisArgs, M: ToRedisArgs, MM: ToRedisArgs>(key: K, min: M, max: MM) {","highlight_start":1,"highlight_end":95},{"text":"        cmd(\"ZREMRANGEBYSCORE\").arg(key).arg(min).arg(max)","highlight_start":1,"highlight_end":59},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index, with scores","highlight_start":1,"highlight_end":73},{"text":"    /// ordered from high to low.","highlight_start":1,"highlight_end":34},{"text":"    fn zrevrange<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"ZREVRANGE\").arg(key).arg(start).arg(stop)","highlight_start":1,"highlight_end":55},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by index, with scores","highlight_start":1,"highlight_end":73},{"text":"    /// ordered from high to low.","highlight_start":1,"highlight_end":34},{"text":"    fn zrevrange_withscores<K: ToRedisArgs>(key: K, start: isize, stop: isize) {","highlight_start":1,"highlight_end":81},{"text":"        cmd(\"ZREVRANGE\").arg(key).arg(start).arg(stop).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":73},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score.","highlight_start":1,"highlight_end":61},{"text":"    fn zrevrangebyscore<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":100},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min)","highlight_start":1,"highlight_end":59},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with scores.","highlight_start":1,"highlight_end":73},{"text":"    fn zrevrangebyscore_withscores<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>(key: K, max: MM, min: M) {","highlight_start":1,"highlight_end":111},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":77},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit.","highlight_start":1,"highlight_end":72},{"text":"    fn zrevrangebyscore_limit<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>","highlight_start":1,"highlight_end":79},{"text":"            (key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":95},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return a range of members in a sorted set, by score with limit with scores.","highlight_start":1,"highlight_end":84},{"text":"    fn zrevrangebyscore_limit_withscores<K: ToRedisArgs, MM: ToRedisArgs, M: ToRedisArgs>","highlight_start":1,"highlight_end":90},{"text":"            (key: K, max: MM, min: M, offset: isize, count: isize) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZREVRANGEBYSCORE\").arg(key).arg(max).arg(min).arg(\"WITHSCORES\")","highlight_start":1,"highlight_end":77},{"text":"            .arg(\"LIMIT\").arg(offset).arg(count)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determine the index of a member in a sorted set, with scores ordered from high to low.","highlight_start":1,"highlight_end":95},{"text":"    fn zrevrank<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"ZREVRANK\").arg(key).arg(member)","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the score associated with the given member in a sorted set.","highlight_start":1,"highlight_end":72},{"text":"    fn zscore<K: ToRedisArgs, M: ToRedisArgs>(key: K, member: M) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"ZSCORE\").arg(key).arg(member)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Get the scores associated with multiple members in a sorted set.","highlight_start":1,"highlight_end":73},{"text":"    fn zscore_multiple<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: &'a [M]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZMSCORE\").arg(key).arg(members)","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":74},{"text":"    /// a new key using SUM as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zunionstore<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":79},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys)","highlight_start":1,"highlight_end":65},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":74},{"text":"    /// a new key using MIN as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zunionstore_min<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\")","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Unions multiple sorted sets and store the resulting sorted set in","highlight_start":1,"highlight_end":74},{"text":"    /// a new key using MAX as aggregation function.","highlight_start":1,"highlight_end":53},{"text":"    fn zunionstore_max<D: ToRedisArgs, K: ToRedisArgs>(dstkey: D, keys: &'a [K]) {","highlight_start":1,"highlight_end":83},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\")","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore`], but with the ability to specify a","highlight_start":1,"highlight_end":69},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zunionstore_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":108},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":93},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore_min`], but with the ability to specify a","highlight_start":1,"highlight_end":73},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zunionstore_min_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":112},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MIN\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":121},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [`Commands::zunionstore_max`], but with the ability to specify a","highlight_start":1,"highlight_end":73},{"text":"    /// multiplication factor for each sorted set by pairing one with each key","highlight_start":1,"highlight_end":79},{"text":"    /// in a tuple.","highlight_start":1,"highlight_end":20},{"text":"    fn zunionstore_max_weights<D: ToRedisArgs, K: ToRedisArgs, W: ToRedisArgs>(dstkey: D, keys: &'a [(K, W)]) {","highlight_start":1,"highlight_end":112},{"text":"        let (keys, weights): (Vec<&K>, Vec<&W>) = keys.iter().map(|(key, weight)| (key, weight)).unzip();","highlight_start":1,"highlight_end":106},{"text":"        cmd(\"ZUNIONSTORE\").arg(dstkey).arg(keys.len()).arg(keys).arg(\"AGGREGATE\").arg(\"MAX\").arg(\"WEIGHTS\").arg(weights)","highlight_start":1,"highlight_end":121},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // hyperloglog commands","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Adds the specified elements to the specified HyperLogLog.","highlight_start":1,"highlight_end":66},{"text":"    fn pfadd<K: ToRedisArgs, E: ToRedisArgs>(key: K, element: E) {","highlight_start":1,"highlight_end":67},{"text":"        cmd(\"PFADD\").arg(key).arg(element)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the approximated cardinality of the set(s) observed by the","highlight_start":1,"highlight_end":74},{"text":"    /// HyperLogLog at key(s).","highlight_start":1,"highlight_end":31},{"text":"    fn pfcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"PFCOUNT\").arg(key)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Merge N different HyperLogLogs into a single one.","highlight_start":1,"highlight_end":58},{"text":"    fn pfmerge<D: ToRedisArgs, S: ToRedisArgs>(dstkey: D, srckeys: S) {","highlight_start":1,"highlight_end":72},{"text":"        cmd(\"PFMERGE\").arg(dstkey).arg(srckeys)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Posts a message to the given channel.","highlight_start":1,"highlight_end":46},{"text":"    fn publish<K: ToRedisArgs, E: ToRedisArgs>(channel: K, message: E) {","highlight_start":1,"highlight_end":73},{"text":"        cmd(\"PUBLISH\").arg(channel).arg(message)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Object commands","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the encoding of a key.","highlight_start":1,"highlight_end":39},{"text":"    fn object_encoding<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":49},{"text":"        cmd(\"OBJECT\").arg(\"ENCODING\").arg(key)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the time in seconds since the last access of a key.","highlight_start":1,"highlight_end":68},{"text":"    fn object_idletime<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":49},{"text":"        cmd(\"OBJECT\").arg(\"IDLETIME\").arg(key)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the logarithmic access frequency counter of a key.","highlight_start":1,"highlight_end":67},{"text":"    fn object_freq<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":45},{"text":"        cmd(\"OBJECT\").arg(\"FREQ\").arg(key)","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the reference count of a key.","highlight_start":1,"highlight_end":46},{"text":"    fn object_refcount<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":49},{"text":"        cmd(\"OBJECT\").arg(\"REFCOUNT\").arg(key)","highlight_start":1,"highlight_end":47},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // ACL commands","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// When Redis is configured to use an ACL file (with the aclfile","highlight_start":1,"highlight_end":70},{"text":"    /// configuration option), this command will reload the ACLs from the file,","highlight_start":1,"highlight_end":80},{"text":"    /// replacing all the current ACL rules with the ones defined in the file.","highlight_start":1,"highlight_end":79},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_load<>() {","highlight_start":1,"highlight_end":22},{"text":"        cmd(\"ACL\").arg(\"LOAD\")","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// When Redis is configured to use an ACL file (with the aclfile","highlight_start":1,"highlight_end":70},{"text":"    /// configuration option), this command will save the currently defined","highlight_start":1,"highlight_end":76},{"text":"    /// ACLs from the server memory to the ACL file.","highlight_start":1,"highlight_end":53},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_save<>() {","highlight_start":1,"highlight_end":22},{"text":"        cmd(\"ACL\").arg(\"SAVE\")","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows the currently active ACL rules in the Redis server.","highlight_start":1,"highlight_end":66},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_list<>() {","highlight_start":1,"highlight_end":22},{"text":"        cmd(\"ACL\").arg(\"LIST\")","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows a list of all the usernames of the currently configured users in","highlight_start":1,"highlight_end":79},{"text":"    /// the Redis ACL system.","highlight_start":1,"highlight_end":30},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_users<>() {","highlight_start":1,"highlight_end":23},{"text":"        cmd(\"ACL\").arg(\"USERS\")","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns all the rules defined for an existing ACL user.","highlight_start":1,"highlight_end":64},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_getuser<K: ToRedisArgs>(username: K) {","highlight_start":1,"highlight_end":50},{"text":"        cmd(\"ACL\").arg(\"GETUSER\").arg(username)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an ACL user without any privilege.","highlight_start":1,"highlight_end":51},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_setuser<K: ToRedisArgs>(username: K) {","highlight_start":1,"highlight_end":50},{"text":"        cmd(\"ACL\").arg(\"SETUSER\").arg(username)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an ACL user with the specified rules or modify the rules of","highlight_start":1,"highlight_end":76},{"text":"    /// an existing user.","highlight_start":1,"highlight_end":26},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_setuser_rules<K: ToRedisArgs>(username: K, rules: &'a [acl::Rule]) {","highlight_start":1,"highlight_end":80},{"text":"        cmd(\"ACL\").arg(\"SETUSER\").arg(username).arg(rules)","highlight_start":1,"highlight_end":59},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Delete all the specified ACL users and terminate all the connections","highlight_start":1,"highlight_end":77},{"text":"    /// that are authenticated with such users.","highlight_start":1,"highlight_end":48},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_deluser<K: ToRedisArgs>(usernames: &'a [K]) {","highlight_start":1,"highlight_end":57},{"text":"        cmd(\"ACL\").arg(\"DELUSER\").arg(usernames)","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows the available ACL categories.","highlight_start":1,"highlight_end":44},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_cat<>() {","highlight_start":1,"highlight_end":21},{"text":"        cmd(\"ACL\").arg(\"CAT\")","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows all the Redis commands in the specified category.","highlight_start":1,"highlight_end":64},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_cat_categoryname<K: ToRedisArgs>(categoryname: K) {","highlight_start":1,"highlight_end":63},{"text":"        cmd(\"ACL\").arg(\"CAT\").arg(categoryname)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Generates a 256-bits password starting from /dev/urandom if available.","highlight_start":1,"highlight_end":79},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_genpass<>() {","highlight_start":1,"highlight_end":25},{"text":"        cmd(\"ACL\").arg(\"GENPASS\")","highlight_start":1,"highlight_end":34},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Generates a 1-to-1024-bits password starting from /dev/urandom if available.","highlight_start":1,"highlight_end":85},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_genpass_bits<>(bits: isize) {","highlight_start":1,"highlight_end":41},{"text":"        cmd(\"ACL\").arg(\"GENPASS\").arg(bits)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the username the current connection is authenticated with.","highlight_start":1,"highlight_end":75},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_whoami<>() {","highlight_start":1,"highlight_end":24},{"text":"        cmd(\"ACL\").arg(\"WHOAMI\")","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Shows a list of recent ACL security events","highlight_start":1,"highlight_end":51},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_log<>(count: isize) {","highlight_start":1,"highlight_end":33},{"text":"        cmd(\"ACL\").arg(\"LOG\").arg(count)","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Clears the ACL log.","highlight_start":1,"highlight_end":28},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_log_reset<>() {","highlight_start":1,"highlight_end":27},{"text":"        cmd(\"ACL\").arg(\"LOG\").arg(\"RESET\")","highlight_start":1,"highlight_end":43},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns a helpful text describing the different subcommands.","highlight_start":1,"highlight_end":69},{"text":"    #[cfg(feature = \"acl\")]","highlight_start":1,"highlight_end":28},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"acl\")))]","highlight_start":1,"highlight_end":51},{"text":"    fn acl_help<>() {","highlight_start":1,"highlight_end":22},{"text":"        cmd(\"ACL\").arg(\"HELP\")","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    // geospatial commands","highlight_start":1,"highlight_end":27},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Adds the specified geospatial items to the specified key.","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Every member has to be written as a tuple of `(longitude, latitude,","highlight_start":1,"highlight_end":76},{"text":"    /// member_name)`. It can be a single tuple, or a vector of tuples.","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `longitude, latitude` can be set using [`redis::geo::Coord`][1].","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [1]: ./geo/struct.Coord.html","highlight_start":1,"highlight_end":37},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Returns the number of elements added to the sorted set, not including","highlight_start":1,"highlight_end":78},{"text":"    /// elements already existing for which the score was updated.","highlight_start":1,"highlight_end":67},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Example","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, Connection, RedisResult};","highlight_start":1,"highlight_end":56},{"text":"    /// use redis::geo::Coord;","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn add_point(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":67},{"text":"    ///     con.geo_add(\"my_gis\", (Coord::lon_lat(13.361389, 38.115556), \"Palermo\"))","highlight_start":1,"highlight_end":85},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn add_point_with_tuples(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":79},{"text":"    ///     con.geo_add(\"my_gis\", (\"13.361389\", \"38.115556\", \"Palermo\"))","highlight_start":1,"highlight_end":73},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn add_many_points(con: &mut Connection) -> RedisResult<isize> {","highlight_start":1,"highlight_end":73},{"text":"    ///     con.geo_add(\"my_gis\", &[","highlight_start":1,"highlight_end":37},{"text":"    ///         (\"13.361389\", \"38.115556\", \"Palermo\"),","highlight_start":1,"highlight_end":55},{"text":"    ///         (\"15.087269\", \"37.502669\", \"Catania\")","highlight_start":1,"highlight_end":54},{"text":"    ///     ])","highlight_start":1,"highlight_end":15},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_add<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"GEOADD\").arg(key).arg(members)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the distance between two members in the geospatial index","highlight_start":1,"highlight_end":72},{"text":"    /// represented by the sorted set.","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If one or both the members are missing, the command returns NULL, so","highlight_start":1,"highlight_end":77},{"text":"    /// it may be convenient to parse its response as either `Option<f64>` or","highlight_start":1,"highlight_end":78},{"text":"    /// `Option<String>`.","highlight_start":1,"highlight_end":26},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Example","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":44},{"text":"    /// use redis::geo::Unit;","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn get_dists(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":52},{"text":"    ///     let x: RedisResult<f64> = con.geo_dist(","highlight_start":1,"highlight_end":52},{"text":"    ///         \"my_gis\",","highlight_start":1,"highlight_end":26},{"text":"    ///         \"Palermo\",","highlight_start":1,"highlight_end":27},{"text":"    ///         \"Catania\",","highlight_start":1,"highlight_end":27},{"text":"    ///         Unit::Kilometers","highlight_start":1,"highlight_end":33},{"text":"    ///     );","highlight_start":1,"highlight_end":15},{"text":"    ///     // x is Ok(166.2742)","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///     let x: RedisResult<Option<f64>> = con.geo_dist(","highlight_start":1,"highlight_end":60},{"text":"    ///         \"my_gis\",","highlight_start":1,"highlight_end":26},{"text":"    ///         \"Palermo\",","highlight_start":1,"highlight_end":27},{"text":"    ///         \"Atlantis\",","highlight_start":1,"highlight_end":28},{"text":"    ///         Unit::Meters","highlight_start":1,"highlight_end":29},{"text":"    ///     );","highlight_start":1,"highlight_end":15},{"text":"    ///     // x is Ok(None)","highlight_start":1,"highlight_end":29},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_dist<K: ToRedisArgs, M1: ToRedisArgs, M2: ToRedisArgs>(","highlight_start":1,"highlight_end":67},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        member1: M1,","highlight_start":1,"highlight_end":21},{"text":"        member2: M2,","highlight_start":1,"highlight_end":21},{"text":"        unit: geo::Unit","highlight_start":1,"highlight_end":24},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"GEODIST\")","highlight_start":1,"highlight_end":23},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(member1)","highlight_start":1,"highlight_end":26},{"text":"            .arg(member2)","highlight_start":1,"highlight_end":26},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":23},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return valid [Geohash][1] strings representing the position of one or","highlight_start":1,"highlight_end":78},{"text":"    /// more members of the geospatial index represented by the sorted set at","highlight_start":1,"highlight_end":78},{"text":"    /// key.","highlight_start":1,"highlight_end":13},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [1]: https://en.wikipedia.org/wiki/Geohash","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Example","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn get_hash(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":51},{"text":"    ///     let x: RedisResult<Vec<String>> = con.geo_hash(\"my_gis\", \"Palermo\");","highlight_start":1,"highlight_end":81},{"text":"    ///     // x is vec![\"sqc8b49rny0\"]","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///     let x: RedisResult<Vec<String>> = con.geo_hash(\"my_gis\", &[\"Palermo\", \"Catania\"]);","highlight_start":1,"highlight_end":95},{"text":"    ///     // x is vec![\"sqc8b49rny0\", \"sqdtr74hyu0\"]","highlight_start":1,"highlight_end":55},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_hash<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":70},{"text":"        cmd(\"GEOHASH\").arg(key).arg(members)","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the positions of all the specified members of the geospatial","highlight_start":1,"highlight_end":76},{"text":"    /// index represented by the sorted set at key.","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Every position is a pair of `(longitude, latitude)`. [`redis::geo::Coord`][1]","highlight_start":1,"highlight_end":86},{"text":"    /// can be used to convert these value in a struct.","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [1]: ./geo/struct.Coord.html","highlight_start":1,"highlight_end":37},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Example","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":44},{"text":"    /// use redis::geo::Coord;","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn get_position(con: &mut redis::Connection) {","highlight_start":1,"highlight_end":55},{"text":"    ///     let x: RedisResult<Vec<Vec<f64>>> = con.geo_pos(\"my_gis\", &[\"Palermo\", \"Catania\"]);","highlight_start":1,"highlight_end":96},{"text":"    ///     // x is [ [ 13.361389, 38.115556 ], [ 15.087269, 37.502669 ] ];","highlight_start":1,"highlight_end":76},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///     let x: Vec<Coord<f64>> = con.geo_pos(\"my_gis\", \"Palermo\").unwrap();","highlight_start":1,"highlight_end":80},{"text":"    ///     // x[0].longitude is 13.361389","highlight_start":1,"highlight_end":43},{"text":"    ///     // x[0].latitude is 38.115556","highlight_start":1,"highlight_end":42},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_pos<K: ToRedisArgs, M: ToRedisArgs>(key: K, members: M) {","highlight_start":1,"highlight_end":69},{"text":"        cmd(\"GEOPOS\").arg(key).arg(members)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Return the members of a sorted set populated with geospatial information","highlight_start":1,"highlight_end":81},{"text":"    /// using [`geo_add`](#method.geo_add), which are within the borders of the area","highlight_start":1,"highlight_end":85},{"text":"    /// specified with the center location and the maximum distance from the center","highlight_start":1,"highlight_end":84},{"text":"    /// (the radius).","highlight_start":1,"highlight_end":22},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Every item in the result can be read with [`redis::geo::RadiusSearchResult`][1],","highlight_start":1,"highlight_end":89},{"text":"    /// which support the multiple formats returned by `GEORADIUS`.","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [1]: ./geo/struct.RadiusSearchResult.html","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```rust,no_run","highlight_start":1,"highlight_end":23},{"text":"    /// use redis::{Commands, RedisResult};","highlight_start":1,"highlight_end":44},{"text":"    /// use redis::geo::{RadiusOptions, RadiusSearchResult, RadiusOrder, Unit};","highlight_start":1,"highlight_end":80},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// fn radius(con: &mut redis::Connection) -> Vec<RadiusSearchResult> {","highlight_start":1,"highlight_end":76},{"text":"    ///     let opts = RadiusOptions::default().with_dist().order(RadiusOrder::Asc);","highlight_start":1,"highlight_end":85},{"text":"    ///     con.geo_radius(\"my_gis\", 15.90, 37.21, 51.39, Unit::Kilometers, opts).unwrap()","highlight_start":1,"highlight_end":91},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_radius<K: ToRedisArgs>(","highlight_start":1,"highlight_end":35},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        longitude: f64,","highlight_start":1,"highlight_end":24},{"text":"        latitude: f64,","highlight_start":1,"highlight_end":23},{"text":"        radius: f64,","highlight_start":1,"highlight_end":21},{"text":"        unit: geo::Unit,","highlight_start":1,"highlight_end":25},{"text":"        options: geo::RadiusOptions","highlight_start":1,"highlight_end":36},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"GEORADIUS\")","highlight_start":1,"highlight_end":25},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(longitude)","highlight_start":1,"highlight_end":28},{"text":"            .arg(latitude)","highlight_start":1,"highlight_end":27},{"text":"            .arg(radius)","highlight_start":1,"highlight_end":25},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":23},{"text":"            .arg(options)","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Retrieve members selected by distance with the center of `member`. The","highlight_start":1,"highlight_end":79},{"text":"    /// member itself is always contained in the results.","highlight_start":1,"highlight_end":58},{"text":"    #[cfg(feature = \"geospatial\")]","highlight_start":1,"highlight_end":35},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"geospatial\")))]","highlight_start":1,"highlight_end":58},{"text":"    fn geo_radius_by_member<K: ToRedisArgs, M: ToRedisArgs>(","highlight_start":1,"highlight_end":61},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        member: M,","highlight_start":1,"highlight_end":19},{"text":"        radius: f64,","highlight_start":1,"highlight_end":21},{"text":"        unit: geo::Unit,","highlight_start":1,"highlight_end":25},{"text":"        options: geo::RadiusOptions","highlight_start":1,"highlight_end":36},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"GEORADIUSBYMEMBER\")","highlight_start":1,"highlight_end":33},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(member)","highlight_start":1,"highlight_end":25},{"text":"            .arg(radius)","highlight_start":1,"highlight_end":25},{"text":"            .arg(unit)","highlight_start":1,"highlight_end":23},{"text":"            .arg(options)","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    // streams commands","highlight_start":1,"highlight_end":24},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Ack pending stream messages checked out by a consumer.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XACK <key> <group> <id> <id> ... <id>","highlight_start":1,"highlight_end":46},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xack<K: ToRedisArgs, G: ToRedisArgs, I: ToRedisArgs>(","highlight_start":1,"highlight_end":61},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        ids: &'a [I]) {","highlight_start":1,"highlight_end":24},{"text":"        cmd(\"XACK\")","highlight_start":1,"highlight_end":20},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add a stream message by `key`. Use `*` as the `id` for the current timestamp.","highlight_start":1,"highlight_end":86},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XADD key <ID or *> [field value] [field value] ...","highlight_start":1,"highlight_end":59},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xadd<K: ToRedisArgs, ID: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(","highlight_start":1,"highlight_end":78},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        id: ID,","highlight_start":1,"highlight_end":16},{"text":"        items: &'a [(F, V)]","highlight_start":1,"highlight_end":28},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XADD\").arg(key).arg(id).arg(items)","highlight_start":1,"highlight_end":48},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// BTreeMap variant for adding a stream message by `key`.","highlight_start":1,"highlight_end":63},{"text":"    /// Use `*` as the `id` for the current timestamp.","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XADD key <ID or *> [rust BTreeMap] ...","highlight_start":1,"highlight_end":47},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xadd_map<K: ToRedisArgs, ID: ToRedisArgs, BTM: ToRedisArgs>(","highlight_start":1,"highlight_end":68},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        id: ID,","highlight_start":1,"highlight_end":16},{"text":"        map: BTM","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XADD\").arg(key).arg(id).arg(map)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Add a stream message while capping the stream at a maxlength.","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XADD key [MAXLEN [~|=] <count>] <ID or *> [field value] [field value] ...","highlight_start":1,"highlight_end":82},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xadd_maxlen<","highlight_start":1,"highlight_end":20},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        ID: ToRedisArgs,","highlight_start":1,"highlight_end":25},{"text":"        F: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        V: ToRedisArgs","highlight_start":1,"highlight_end":23},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        maxlen: streams::StreamMaxlen,","highlight_start":1,"highlight_end":39},{"text":"        id: ID,","highlight_start":1,"highlight_end":16},{"text":"        items: &'a [(F, V)]","highlight_start":1,"highlight_end":28},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XADD\")","highlight_start":1,"highlight_end":20},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(maxlen)","highlight_start":1,"highlight_end":25},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"            .arg(items)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// BTreeMap variant for adding a stream message while capping the stream at a maxlength.","highlight_start":1,"highlight_end":94},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XADD key [MAXLEN [~|=] <count>] <ID or *> [rust BTreeMap] ...","highlight_start":1,"highlight_end":70},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xadd_maxlen_map<K: ToRedisArgs, ID: ToRedisArgs, BTM: ToRedisArgs>(","highlight_start":1,"highlight_end":75},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        maxlen: streams::StreamMaxlen,","highlight_start":1,"highlight_end":39},{"text":"        id: ID,","highlight_start":1,"highlight_end":16},{"text":"        map: BTM","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XADD\")","highlight_start":1,"highlight_end":20},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(maxlen)","highlight_start":1,"highlight_end":25},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"            .arg(map)","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Claim pending, unacked messages, after some period of time,","highlight_start":1,"highlight_end":68},{"text":"    /// currently checked out by another consumer.","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method only accepts the must-have arguments for claiming messages.","highlight_start":1,"highlight_end":80},{"text":"    /// If optional arguments are required, see `xclaim_options` below.","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XCLAIM <key> <group> <consumer> <min-idle-time> [<ID-1> <ID-2>]","highlight_start":1,"highlight_end":72},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xclaim<K: ToRedisArgs, G: ToRedisArgs, C: ToRedisArgs, MIT: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":98},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        consumer: C,","highlight_start":1,"highlight_end":21},{"text":"        min_idle_time: MIT,","highlight_start":1,"highlight_end":28},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":22},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XCLAIM\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":27},{"text":"            .arg(min_idle_time)","highlight_start":1,"highlight_end":32},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the optional arguments version for claiming unacked, pending messages","highlight_start":1,"highlight_end":86},{"text":"    /// currently checked out by another consumer.","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```no_run","highlight_start":1,"highlight_end":18},{"text":"    /// use redis::{Connection,Commands,RedisResult};","highlight_start":1,"highlight_end":54},{"text":"    /// use redis::streams::{StreamClaimOptions,StreamClaimReply};","highlight_start":1,"highlight_end":67},{"text":"    /// let client = redis::Client::open(\"redis://127.0.0.1/0\").unwrap();","highlight_start":1,"highlight_end":74},{"text":"    /// let mut con = client.get_connection().unwrap();","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Claim all pending messages for key \"k1\",","highlight_start":1,"highlight_end":52},{"text":"    /// // from group \"g1\", checked out by consumer \"c1\"","highlight_start":1,"highlight_end":57},{"text":"    /// // for 10ms with RETRYCOUNT 2 and FORCE","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let opts = StreamClaimOptions::default()","highlight_start":1,"highlight_end":49},{"text":"    ///     .with_force()","highlight_start":1,"highlight_end":26},{"text":"    ///     .retry(2);","highlight_start":1,"highlight_end":23},{"text":"    /// let results: RedisResult<StreamClaimReply> =","highlight_start":1,"highlight_end":53},{"text":"    ///     con.xclaim_options(\"k1\", \"g1\", \"c1\", 10, &[\"0\"], opts);","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // All optional arguments return a `Result<StreamClaimReply>` with one exception:","highlight_start":1,"highlight_end":90},{"text":"    /// // Passing JUSTID returns only the message `id` and omits the HashMap for each message.","highlight_start":1,"highlight_end":96},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let opts = StreamClaimOptions::default()","highlight_start":1,"highlight_end":49},{"text":"    ///     .with_justid();","highlight_start":1,"highlight_end":28},{"text":"    /// let results: RedisResult<Vec<String>> =","highlight_start":1,"highlight_end":48},{"text":"    ///     con.xclaim_options(\"k1\", \"g1\", \"c1\", 10, &[\"0\"], opts);","highlight_start":1,"highlight_end":68},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2>","highlight_start":1,"highlight_end":70},{"text":"    ///     [IDLE <milliseconds>] [TIME <mstime>] [RETRYCOUNT <count>]","highlight_start":1,"highlight_end":71},{"text":"    ///     [FORCE] [JUSTID]","highlight_start":1,"highlight_end":29},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xclaim_options<","highlight_start":1,"highlight_end":23},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        C: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        MIT: ToRedisArgs,","highlight_start":1,"highlight_end":26},{"text":"        ID: ToRedisArgs","highlight_start":1,"highlight_end":24},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        consumer: C,","highlight_start":1,"highlight_end":21},{"text":"        min_idle_time: MIT,","highlight_start":1,"highlight_end":28},{"text":"        ids: &'a [ID],","highlight_start":1,"highlight_end":23},{"text":"        options: streams::StreamClaimOptions","highlight_start":1,"highlight_end":45},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XCLAIM\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":27},{"text":"            .arg(min_idle_time)","highlight_start":1,"highlight_end":32},{"text":"            .arg(ids)","highlight_start":1,"highlight_end":22},{"text":"            .arg(options)","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Deletes a list of `id`s for a given stream `key`.","highlight_start":1,"highlight_end":58},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XDEL <key> [<ID1> <ID2> ... <IDN>]","highlight_start":1,"highlight_end":43},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xdel<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":46},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":22},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XDEL\").arg(key).arg(ids)","highlight_start":1,"highlight_end":38},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This command is used for creating a consumer `group`. It expects the stream key","highlight_start":1,"highlight_end":88},{"text":"    /// to already exist. Otherwise, use `xgroup_create_mkstream` if it doesn't.","highlight_start":1,"highlight_end":81},{"text":"    /// The `id` is the starting message id all consumers should read from. Use `$` If you want","highlight_start":1,"highlight_end":96},{"text":"    /// all consumers to read from the last message added to stream.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP CREATE <key> <groupname> <id or $>","highlight_start":1,"highlight_end":50},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_create<K: ToRedisArgs, G: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":71},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        id: ID","highlight_start":1,"highlight_end":15},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"CREATE\")","highlight_start":1,"highlight_end":27},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the alternate version for creating a consumer `group`","highlight_start":1,"highlight_end":70},{"text":"    /// which makes the stream if it doesn't exist.","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP CREATE <key> <groupname> <id or $> [MKSTREAM]","highlight_start":1,"highlight_end":61},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_create_mkstream<","highlight_start":1,"highlight_end":31},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        ID: ToRedisArgs","highlight_start":1,"highlight_end":24},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        id: ID","highlight_start":1,"highlight_end":15},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"CREATE\")","highlight_start":1,"highlight_end":27},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"            .arg(\"MKSTREAM\")","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Alter which `id` you want consumers to begin reading from an existing","highlight_start":1,"highlight_end":78},{"text":"    /// consumer `group`.","highlight_start":1,"highlight_end":26},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP SETID <key> <groupname> <id or $>","highlight_start":1,"highlight_end":49},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_setid<K: ToRedisArgs, G: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":70},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        id: ID","highlight_start":1,"highlight_end":15},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"SETID\")","highlight_start":1,"highlight_end":26},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(id)","highlight_start":1,"highlight_end":21},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Destroy an existing consumer `group` for a given stream `key`","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP SETID <key> <groupname> <id or $>","highlight_start":1,"highlight_end":49},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_destroy<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":55},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\").arg(\"DESTROY\").arg(key).arg(group)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This deletes a `consumer` from an existing consumer `group`","highlight_start":1,"highlight_end":68},{"text":"    /// for given stream `key.","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XGROUP DELCONSUMER <key> <groupname> <consumername>","highlight_start":1,"highlight_end":60},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xgroup_delconsumer<K: ToRedisArgs, G: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":75},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        consumer: C","highlight_start":1,"highlight_end":20},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XGROUP\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"DELCONSUMER\")","highlight_start":1,"highlight_end":32},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This returns all info details about","highlight_start":1,"highlight_end":44},{"text":"    /// which consumers have read messages for given consumer `group`.","highlight_start":1,"highlight_end":71},{"text":"    /// Take note of the StreamInfoConsumersReply return type.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":70},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XINFO CONSUMERS <key> <group>","highlight_start":1,"highlight_end":38},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xinfo_consumers<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":56},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XINFO\")","highlight_start":1,"highlight_end":21},{"text":"            .arg(\"CONSUMERS\")","highlight_start":1,"highlight_end":30},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns all consumer `group`s created for a given stream `key`.","highlight_start":1,"highlight_end":72},{"text":"    /// Take note of the StreamInfoGroupsReply return type.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":70},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XINFO GROUPS <key>","highlight_start":1,"highlight_end":27},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xinfo_groups<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":46},{"text":"        cmd(\"XINFO\").arg(\"GROUPS\").arg(key)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns info about high-level stream details","highlight_start":1,"highlight_end":53},{"text":"    /// (first & last message `id`, length, number of groups, etc.)","highlight_start":1,"highlight_end":68},{"text":"    /// Take note of the StreamInfoStreamReply return type.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// *It's possible this return value might not contain new fields","highlight_start":1,"highlight_end":70},{"text":"    /// added by Redis in future versions.*","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XINFO STREAM <key>","highlight_start":1,"highlight_end":27},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xinfo_stream<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":46},{"text":"        cmd(\"XINFO\").arg(\"STREAM\").arg(key)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the number of messages for a given stream `key`.","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XLEN <key>","highlight_start":1,"highlight_end":19},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xlen<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":38},{"text":"        cmd(\"XLEN\").arg(key)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is a basic version of making XPENDING command calls which only","highlight_start":1,"highlight_end":76},{"text":"    /// passes a stream `key` and consumer `group` and it","highlight_start":1,"highlight_end":58},{"text":"    /// returns details about which consumers have pending messages","highlight_start":1,"highlight_end":68},{"text":"    /// that haven't been acked.","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// You can use this method along with","highlight_start":1,"highlight_end":43},{"text":"    /// `xclaim` or `xclaim_options` for determining which messages","highlight_start":1,"highlight_end":68},{"text":"    /// need to be retried.","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Take note of the StreamPendingReply return type.","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XPENDING <key> <group> [<start> <stop> <count> [<consumer>]]","highlight_start":1,"highlight_end":69},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xpending<K: ToRedisArgs, G: ToRedisArgs>(","highlight_start":1,"highlight_end":49},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G","highlight_start":1,"highlight_end":17},{"text":"    )  {","highlight_start":1,"highlight_end":9},{"text":"        cmd(\"XPENDING\").arg(key).arg(group)","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This XPENDING version returns a list of all messages over the range.","highlight_start":1,"highlight_end":77},{"text":"    /// You can use this for paginating pending messages (but without the message HashMap).","highlight_start":1,"highlight_end":92},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Start and end follow the same rules `xrange` args. Set start to `-`","highlight_start":1,"highlight_end":76},{"text":"    /// and end to `+` for the entire stream.","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Take note of the StreamPendingCountReply return type.","highlight_start":1,"highlight_end":62},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XPENDING <key> <group> <start> <stop> <count>","highlight_start":1,"highlight_end":54},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xpending_count<","highlight_start":1,"highlight_end":23},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        S: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        E: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        C: ToRedisArgs","highlight_start":1,"highlight_end":23},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        count: C","highlight_start":1,"highlight_end":17},{"text":"    )  {","highlight_start":1,"highlight_end":9},{"text":"        cmd(\"XPENDING\")","highlight_start":1,"highlight_end":24},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(start)","highlight_start":1,"highlight_end":24},{"text":"            .arg(end)","highlight_start":1,"highlight_end":22},{"text":"            .arg(count)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// An alternate version of `xpending_count` which filters by `consumer` name.","highlight_start":1,"highlight_end":83},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Start and end follow the same rules `xrange` args. Set start to `-`","highlight_start":1,"highlight_end":76},{"text":"    /// and end to `+` for the entire stream.","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Take note of the StreamPendingCountReply return type.","highlight_start":1,"highlight_end":62},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XPENDING <key> <group> <start> <stop> <count> <consumer>","highlight_start":1,"highlight_end":65},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xpending_consumer_count<","highlight_start":1,"highlight_end":32},{"text":"        K: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        G: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        S: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        E: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        C: ToRedisArgs,","highlight_start":1,"highlight_end":24},{"text":"        CN: ToRedisArgs","highlight_start":1,"highlight_end":24},{"text":"    >(","highlight_start":1,"highlight_end":7},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        group: G,","highlight_start":1,"highlight_end":18},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        count: C,","highlight_start":1,"highlight_end":18},{"text":"        consumer: CN","highlight_start":1,"highlight_end":21},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XPENDING\")","highlight_start":1,"highlight_end":24},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(group)","highlight_start":1,"highlight_end":24},{"text":"            .arg(start)","highlight_start":1,"highlight_end":24},{"text":"            .arg(end)","highlight_start":1,"highlight_end":22},{"text":"            .arg(count)","highlight_start":1,"highlight_end":24},{"text":"            .arg(consumer)","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns a range of messages in a given stream `key`.","highlight_start":1,"highlight_end":61},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Set `start` to `-` to begin at the first message.","highlight_start":1,"highlight_end":58},{"text":"    /// Set `end` to `+` to end the most recent message.","highlight_start":1,"highlight_end":57},{"text":"    /// You can pass message `id` to both `start` and `end`.","highlight_start":1,"highlight_end":61},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Take note of the StreamRangeReply return type.","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XRANGE key start end","highlight_start":1,"highlight_end":29},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrange<K: ToRedisArgs, S: ToRedisArgs, E: ToRedisArgs>(","highlight_start":1,"highlight_end":63},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        end: E","highlight_start":1,"highlight_end":15},{"text":"    )  {","highlight_start":1,"highlight_end":9},{"text":"        cmd(\"XRANGE\").arg(key).arg(start).arg(end)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// A helper method for automatically returning all messages in a stream by `key`.","highlight_start":1,"highlight_end":87},{"text":"    /// **Use with caution!**","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XRANGE key - +","highlight_start":1,"highlight_end":23},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrange_all<K: ToRedisArgs>(key: K)  {","highlight_start":1,"highlight_end":45},{"text":"        cmd(\"XRANGE\").arg(key).arg(\"-\").arg(\"+\")","highlight_start":1,"highlight_end":49},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// A method for paginating a stream by `key`.","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XRANGE key start end [COUNT <n>]","highlight_start":1,"highlight_end":41},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrange_count<K: ToRedisArgs, S: ToRedisArgs, E: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":85},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        count: C","highlight_start":1,"highlight_end":17},{"text":"    )  {","highlight_start":1,"highlight_end":9},{"text":"        cmd(\"XRANGE\")","highlight_start":1,"highlight_end":22},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(start)","highlight_start":1,"highlight_end":24},{"text":"            .arg(end)","highlight_start":1,"highlight_end":22},{"text":"            .arg(\"COUNT\")","highlight_start":1,"highlight_end":26},{"text":"            .arg(count)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Read a list of `id`s for each stream `key`.","highlight_start":1,"highlight_end":52},{"text":"    /// This is the basic form of reading streams.","highlight_start":1,"highlight_end":51},{"text":"    /// For more advanced control, like blocking, limiting, or reading by consumer `group`,","highlight_start":1,"highlight_end":92},{"text":"    /// see `xread_options`.","highlight_start":1,"highlight_end":29},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREAD STREAMS key_1 key_2 ... key_N ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":63},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xread<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":47},{"text":"        keys: &'a [K],","highlight_start":1,"highlight_end":23},{"text":"        ids: &'a [ID]","highlight_start":1,"highlight_end":22},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XREAD\").arg(\"STREAMS\").arg(keys).arg(ids)","highlight_start":1,"highlight_end":55},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This method handles setting optional arguments for","highlight_start":1,"highlight_end":59},{"text":"    /// `XREAD` or `XREADGROUP` Redis commands.","highlight_start":1,"highlight_end":48},{"text":"    /// ```no_run","highlight_start":1,"highlight_end":18},{"text":"    /// use redis::{Connection,RedisResult,Commands};","highlight_start":1,"highlight_end":54},{"text":"    /// use redis::streams::{StreamReadOptions,StreamReadReply};","highlight_start":1,"highlight_end":65},{"text":"    /// let client = redis::Client::open(\"redis://127.0.0.1/0\").unwrap();","highlight_start":1,"highlight_end":74},{"text":"    /// let mut con = client.get_connection().unwrap();","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Read 10 messages from the start of the stream,","highlight_start":1,"highlight_end":58},{"text":"    /// // without registering as a consumer group.","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let opts = StreamReadOptions::default()","highlight_start":1,"highlight_end":48},{"text":"    ///     .count(10);","highlight_start":1,"highlight_end":24},{"text":"    /// let results: RedisResult<StreamReadReply> =","highlight_start":1,"highlight_end":52},{"text":"    ///     con.xread_options(&[\"k1\"], &[\"0\"], &opts);","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Read all undelivered messages for a given","highlight_start":1,"highlight_end":53},{"text":"    /// // consumer group. Be advised: the consumer group must already","highlight_start":1,"highlight_end":71},{"text":"    /// // exist before making this call. Also note: we're passing","highlight_start":1,"highlight_end":67},{"text":"    /// // '>' as the id here, which means all undelivered messages.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let opts = StreamReadOptions::default()","highlight_start":1,"highlight_end":48},{"text":"    ///     .group(\"group-1\", \"consumer-1\");","highlight_start":1,"highlight_end":45},{"text":"    /// let results: RedisResult<StreamReadReply> =","highlight_start":1,"highlight_end":52},{"text":"    ///     con.xread_options(&[\"k1\"], &[\">\"], &opts);","highlight_start":1,"highlight_end":55},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREAD [BLOCK <milliseconds>] [COUNT <count>]","highlight_start":1,"highlight_end":53},{"text":"    ///     STREAMS key_1 key_2 ... key_N","highlight_start":1,"highlight_end":42},{"text":"    ///     ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// XREADGROUP [BLOCK <milliseconds>] [COUNT <count>] [NOACK] [GROUP group-name consumer-name]","highlight_start":1,"highlight_end":99},{"text":"    ///     STREAMS key_1 key_2 ... key_N","highlight_start":1,"highlight_end":42},{"text":"    ///     ID_1 ID_2 ... ID_N","highlight_start":1,"highlight_end":31},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xread_options<K: ToRedisArgs, ID: ToRedisArgs>(","highlight_start":1,"highlight_end":55},{"text":"        keys: &'a [K],","highlight_start":1,"highlight_end":23},{"text":"        ids: &'a [ID],","highlight_start":1,"highlight_end":23},{"text":"        options: &'a streams::StreamReadOptions","highlight_start":1,"highlight_end":48},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(if options.read_only() {","highlight_start":1,"highlight_end":37},{"text":"            \"XREAD\"","highlight_start":1,"highlight_end":20},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"            \"XREADGROUP\"","highlight_start":1,"highlight_end":25},{"text":"        })","highlight_start":1,"highlight_end":11},{"text":"        .arg(options)","highlight_start":1,"highlight_end":22},{"text":"        .arg(\"STREAMS\")","highlight_start":1,"highlight_end":24},{"text":"        .arg(keys)","highlight_start":1,"highlight_end":19},{"text":"        .arg(ids)","highlight_start":1,"highlight_end":18},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange`.","highlight_start":1,"highlight_end":49},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREVRANGE key end start","highlight_start":1,"highlight_end":32},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrevrange<K: ToRedisArgs, E: ToRedisArgs, S: ToRedisArgs>(","highlight_start":1,"highlight_end":66},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        start: S","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XREVRANGE\").arg(key).arg(end).arg(start)","highlight_start":1,"highlight_end":54},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange_all`.","highlight_start":1,"highlight_end":53},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREVRANGE key + -","highlight_start":1,"highlight_end":26},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    fn xrevrange_all<K: ToRedisArgs>(key: K) {","highlight_start":1,"highlight_end":47},{"text":"        cmd(\"XREVRANGE\").arg(key).arg(\"+\").arg(\"-\")","highlight_start":1,"highlight_end":52},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// This is the reverse version of `xrange_count`.","highlight_start":1,"highlight_end":55},{"text":"    /// The same rules apply for `start` and `end` here.","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XREVRANGE key end start [COUNT <n>]","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xrevrange_count<K: ToRedisArgs, E: ToRedisArgs, S: ToRedisArgs, C: ToRedisArgs>(","highlight_start":1,"highlight_end":88},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        end: E,","highlight_start":1,"highlight_end":16},{"text":"        start: S,","highlight_start":1,"highlight_end":18},{"text":"        count: C","highlight_start":1,"highlight_end":17},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XREVRANGE\")","highlight_start":1,"highlight_end":25},{"text":"            .arg(key)","highlight_start":1,"highlight_end":22},{"text":"            .arg(end)","highlight_start":1,"highlight_end":22},{"text":"            .arg(start)","highlight_start":1,"highlight_end":24},{"text":"            .arg(\"COUNT\")","highlight_start":1,"highlight_end":26},{"text":"            .arg(count)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Trim a stream `key` to a MAXLEN count.","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// XTRIM <key> MAXLEN [~|=] <count>  (Same as XADD MAXLEN option)","highlight_start":1,"highlight_end":71},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg(feature = \"streams\")]","highlight_start":1,"highlight_end":32},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"streams\")))]","highlight_start":1,"highlight_end":55},{"text":"    fn xtrim<K: ToRedisArgs>(","highlight_start":1,"highlight_end":30},{"text":"        key: K,","highlight_start":1,"highlight_end":16},{"text":"        maxlen: streams::StreamMaxlen","highlight_start":1,"highlight_end":38},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        cmd(\"XTRIM\").arg(key).arg(maxlen)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"implement_commands!","def_site_span":{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/macros.rs","byte_start":0,"byte_end":31,"line_start":1,"line_end":1,"column_start":1,"column_end":32,"is_primary":false,"text":[{"text":"macro_rules! implement_commands {","highlight_start":1,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `!: FromRedisValue` is not satisfied\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:84:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        conn.expire(session_id, SESSION_TTL).await?;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `FromRedisValue` is not implemented for `!`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `FromRedisValue`:\u001b[0m\n\u001b[0m               ()\u001b[0m\n\u001b[0m               (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m               (T10, T11, T12)\u001b[0m\n\u001b[0m               (T11, T12)\u001b[0m\n\u001b[0m               (T12,)\u001b[0m\n\u001b[0m               (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m               (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m               (T4, T5, T6, T7, T8, T9, T10, T11, T12)\u001b[0m\n\u001b[0m             and 42 others\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: did you intend to use the type `()` here instead?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `redis::AsyncCommands::expire`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/redis-0.23.3/src/commands/mod.rs:41:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimplement_commands! {\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    'a\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m133\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn expire<K: ToRedisArgs>(key: K, seconds: usize) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this associated function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1847\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `AsyncCommands::expire`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `implement_commands` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/routes.rs","byte_start":338,"byte_end":635,"line_start":17,"line_end":22,"column_start":5,"column_end":88,"is_primary":true,"text":[{"text":"    Router::new()","highlight_start":5,"highlight_end":18},{"text":"        .route(\"/health\", get(health_check))","highlight_start":1,"highlight_end":45},{"text":"        .route(\"/users\", post(register_user))","highlight_start":1,"highlight_end":46},{"text":" //       .route(\"/users/:id\", get(get_user_by_id))","highlight_start":1,"highlight_end":52},{"text":"        .route(\"/strategies\", post(create_strategy))","highlight_start":1,"highlight_end":53},{"text":"        .layer(middleware::from_fn_with_state(app_state, middlewares::auth_middleware))","highlight_start":1,"highlight_end":88}],"label":"expected `Router<AppState>`, found `Router<Pool<Postgres>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/routes.rs","byte_start":315,"byte_end":331,"line_start":16,"line_end":16,"column_start":40,"column_end":56,"is_primary":false,"text":[{"text":"pub fn routes(app_state: &AppState) -> Router<AppState> {","highlight_start":40,"highlight_end":56}],"label":"expected `Router<AppState>` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Router<AppState>`\n   found struct `Router<Pool<Postgres>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/routes.rs:17:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub fn routes(app_state: &AppState) -> Router<AppState> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `Router<AppState>` because of return type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Router::new()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .route(\"/health\", get(health_check))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .route(\"/users\", post(register_user))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .layer(middleware::from_fn_with_state(app_state, middlewares::auth_middleware))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_______________________________________________________________________________________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Router<AppState>`, found `Router<Pool<Postgres>>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Router<\u001b[0m\u001b[0m\u001b[1m\u001b[35mAppState\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m              found struct `Router<\u001b[0m\u001b[0m\u001b[1m\u001b[35mPool<Postgres>\u001b[0m\u001b[0m>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `bcrypt`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/auth.rs","byte_start":2725,"byte_end":2731,"line_start":90,"line_end":90,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    bcrypt::hash(password, bcrypt::DEFAULT_COST).map_err(AppError::from)","highlight_start":5,"highlight_end":11}],"label":"use of unresolved module or unlinked crate `bcrypt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `bcrypt`, use `cargo add bcrypt` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `bcrypt`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:90:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    bcrypt::hash(password, bcrypt::DEFAULT_COST).map_err(AppError::from)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of unresolved module or unlinked crate `bcrypt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: if you wanted to use a crate named `bcrypt`, use `cargo add bcrypt` to add it to your `Cargo.toml`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `bcrypt`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/auth.rs","byte_start":2748,"byte_end":2754,"line_start":90,"line_end":90,"column_start":28,"column_end":34,"is_primary":true,"text":[{"text":"    bcrypt::hash(password, bcrypt::DEFAULT_COST).map_err(AppError::from)","highlight_start":28,"highlight_end":34}],"label":"use of unresolved module or unlinked crate `bcrypt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `bcrypt`, use `cargo add bcrypt` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `bcrypt`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:90:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    bcrypt::hash(password, bcrypt::DEFAULT_COST).map_err(AppError::from)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of unresolved module or unlinked crate `bcrypt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: if you wanted to use a crate named `bcrypt`, use `cargo add bcrypt` to add it to your `Cargo.toml`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `bcrypt`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/auth.rs","byte_start":2880,"byte_end":2886,"line_start":94,"line_end":94,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    bcrypt::verify(password, hash).map_err(AppError::from)","highlight_start":5,"highlight_end":11}],"label":"use of unresolved module or unlinked crate `bcrypt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `bcrypt`, use `cargo add bcrypt` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `bcrypt`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/auth.rs:94:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m94\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    bcrypt::verify(password, hash).map_err(AppError::from)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of unresolved module or unlinked crate `bcrypt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: if you wanted to use a crate named `bcrypt`, use `cargo add bcrypt` to add it to your `Cargo.toml`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `FromFn<..., ..., ..., _>: Service<...>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1606,"byte_end":1732,"line_start":62,"line_end":65,"column_start":16,"column_end":10,"is_primary":true,"text":[{"text":"        .layer(axum::middleware::from_fn_with_state(","highlight_start":16,"highlight_end":53},{"text":"            app_state.clone(),","highlight_start":1,"highlight_end":31},{"text":"            crate::middleware::auth_middleware,","highlight_start":1,"highlight_end":48},{"text":"        ))","highlight_start":1,"highlight_end":10}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1600,"byte_end":1605,"line_start":62,"line_end":62,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"        .layer(axum::middleware::from_fn_with_state(","highlight_start":10,"highlight_end":15}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `tower_service::Service<axum::http::Request<Body>>` is not implemented for `FromFn<fn(..., ..., ..., ...) -> ... {auth_middleware}, ..., ..., _>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `tower_service::Service<Request>`:\n  axum::middleware::FromFn<F, S, I, (T1, T2)>\n  axum::middleware::FromFn<F, S, I, (T1, T2, T3)>\n  axum::middleware::FromFn<F, S, I, (T1, T2, T3, T4)>\n  axum::middleware::FromFn<F, S, I, (T1, T2, T3, T4, T5)>\n  axum::middleware::FromFn<F, S, I, (T1, T2, T3, T4, T5, T6)>\n  axum::middleware::FromFn<F, S, I, (T1, T2, T3, T4, T5, T6, T7)>\n  axum::middleware::FromFn<F, S, I, (T1, T2, T3, T4, T5, T6, T7, T8)>\n  axum::middleware::FromFn<F, S, I, (T1, T2, T3, T4, T5, T6, T7, T8, T9)>\nand 8 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `Router::<S>::layer`","code":null,"level":"note","spans":[{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/axum-0.7.9/src/routing/mod.rs","byte_start":8765,"byte_end":8770,"line_start":281,"line_end":281,"column_start":12,"column_end":17,"is_primary":false,"text":[{"text":"    pub fn layer<L>(self, layer: L) -> Router<S>","highlight_start":12,"highlight_end":17}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/axum-0.7.9/src/routing/mod.rs","byte_start":8883,"byte_end":8899,"line_start":284,"line_end":284,"column_start":21,"column_end":37,"is_primary":true,"text":[{"text":"        L::Service: Service<Request> + Clone + Send + 'static,","highlight_start":21,"highlight_end":37}],"label":"required by this bound in `Router::<S>::layer`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/marc/personal/Projects/stratmaker/backend/target/debug/deps/backend-bf9fd617bdf2b737.long-type-17824474784104626776.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `FromFn<..., ..., ..., _>: Service<...>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:62:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        .layer(axum::middleware::from_fn_with_state(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m __________\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            app_state.clone(),\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m64\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            crate::middleware::auth_middleware,\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m65\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        ))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munsatisfied trait bound\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `tower_service::Service<axum::http::Request<Body>>` is not implemented for `FromFn<fn(..., ..., ..., ...) -> ... {auth_middleware}, ..., ..., _>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `tower_service::Service<Request>`:\u001b[0m\n\u001b[0m              axum::middleware::FromFn<F, S, I, (T1, T2)>\u001b[0m\n\u001b[0m              axum::middleware::FromFn<F, S, I, (T1, T2, T3)>\u001b[0m\n\u001b[0m              axum::middleware::FromFn<F, S, I, (T1, T2, T3, T4)>\u001b[0m\n\u001b[0m              axum::middleware::FromFn<F, S, I, (T1, T2, T3, T4, T5)>\u001b[0m\n\u001b[0m              axum::middleware::FromFn<F, S, I, (T1, T2, T3, T4, T5, T6)>\u001b[0m\n\u001b[0m              axum::middleware::FromFn<F, S, I, (T1, T2, T3, T4, T5, T6, T7)>\u001b[0m\n\u001b[0m              axum::middleware::FromFn<F, S, I, (T1, T2, T3, T4, T5, T6, T7, T8)>\u001b[0m\n\u001b[0m              axum::middleware::FromFn<F, S, I, (T1, T2, T3, T4, T5, T6, T7, T8, T9)>\u001b[0m\n\u001b[0m            and 8 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `Router::<S>::layer`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/marc/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/axum-0.7.9/src/routing/mod.rs:284:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m281\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn layer<L>(self, layer: L) -> Router<S>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this associated function\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        L::Service: Service<Request> + Clone + Send + 'static,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Router::<S>::layer`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: the full name for the type has been written to '/home/marc/personal/Projects/stratmaker/backend/target/debug/deps/backend-bf9fd617bdf2b737.long-type-17824474784104626776.txt'\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider using `--verbose` to print the full type name to the console\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `Row`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/db.rs","byte_start":315,"byte_end":318,"line_start":13,"line_end":13,"column_start":36,"column_end":39,"is_primary":true,"text":[{"text":"use sqlx::{PgPool, Pool, Postgres, Row};","highlight_start":36,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `Row`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/db.rs:13:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse sqlx::{PgPool, Pool, Postgres, Row};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 52 previous errors; 8 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 52 previous errors; 8 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0061, E0195, E0252, E0277, E0308, E0412, E0425, E0432, E0433...","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0061, E0195, E0252, E0277, E0308, E0412, E0425, E0432, E0433...\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0061`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0061`.\u001b[0m\n"}
